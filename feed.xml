<?xml version="1.0" encoding="utf-16"?><rss xmlns:a10="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Ian Wold</title><link>https://ian.wold.guru/feed.xml</link><description>Ian Wold's Blog</description><item><guid isPermaLink="false">deploying_aspdotnet_7_projects_with_railway</guid><link>https://ian.wold.guru/Posts/deploying_aspdotnet_7_projects_with_railway.html</link><title>Deploying ASP.NET 7 Projects with Railway</title><description>&lt;p&gt;Nevermind that I haven't posted in more than 6 years, &lt;a href="https://www.railway.app"&gt;Railway&lt;/a&gt; is a startup cloud infrastructure provider that has gained a fair amount of traction for being easy to use and very cost effective to get started with. It's pretty barebones right now, but that makes it especially great for hobbyist projects. They have a free introductory tier, but then the next tier is $5/month plus a small resource usage fee. Really, their pricing is fantastic.&lt;/p&gt;
&lt;p&gt;When you deploy with Railway, they'll shove your app into a Docker container and handle the management/scaling/etc. behind the scenes. In addition, they have the ability to stand up a database for you - as of the time of this writing, you can choose PostgreSQL, MySQL, Mongo, and Redis. That said, they of course allow you to deploy any docker image or volume, so if you're willing to put in a little more work I imagine you can make any stack work for you. That all means of course that Railway probably isn't the best solution if you need control over container orchestration, but for CRUD projects and startups it seems quite promising to me.&lt;/p&gt;
&lt;p&gt;What's especially great is their integration with GitHub - it takes just a couple minutes to sign up for Railway, authenticate with GitHub, point it at a repo, and Railway takes care of the deployment from there. It has some magic to sense what kind of project your repo is and attempt to construct a build pipeline for your project right away. This doesn't work too well in .NET, but their interface is very sparse and easy to use to get up and going with it.&lt;/p&gt;
&lt;p&gt;In the remainder of this article, I'm going to be demonstrating how to get a .NET 7 app deployed with Railway. I'll start with a simple ASP.NET API, and then I'll demonstrate getting Blazor working. I'd encourage you to follow along with me - it's no cost to you (you don't even need to type in a credit card) and I think you'll be impressed with how easy it is to get a little hobby app deployed with Railway.&lt;/p&gt;
&lt;h1&gt;Setting Up&lt;/h1&gt;
&lt;p&gt;We'll just need three things to get started:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An ASP.NET API&lt;/li&gt;
&lt;li&gt;A GitHub repo for that API&lt;/li&gt;
&lt;li&gt;A Railway account&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's go top to bottom there&lt;/p&gt;
&lt;h2&gt;Setting up a new .NET API&lt;/h2&gt;
&lt;p&gt;To begin with, I'll assume you have .NET installed, and you have a GitHub account. We can create a barebones API from the console:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;dotnet new web -n RailwayAspApiDemo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This starts us off with the following, which will output &amp;quot;Hello, World!&amp;quot; at &lt;code&gt;/&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet(&amp;quot;/&amp;quot;, () =&amp;gt; &amp;quot;Hello World!&amp;quot;);

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;MyApi&lt;/code&gt; directory, we can create a new repo. I'd recommend adding the &lt;a href="https://raw.githubusercontent.com/github/gitignore/main/VisualStudio.gitignore"&gt;VS .gitignore&lt;/a&gt; first, too.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;git add .
git commit -m &amp;quot;Getting Started&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you've created a repo in GitHub, we can push it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;git remote add origin https://github.com/{username}/RailwayAspApiDemo.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For reference, you can &lt;a href="https://github.com/IanWold/RailwayAspApiDemo"&gt;see this repo here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Setting up Railway&lt;/h2&gt;
&lt;p&gt;This is real simple - just go to &lt;a href="http://railway.app"&gt;railway.app&lt;/a&gt;, click login at the top, and then you can login with GitHub.&lt;/p&gt;
&lt;p&gt;That's all you need in order to set up Railway. Seriously! Of course we're going to push ahead and click that shiny New Project button though...&lt;/p&gt;
&lt;h1&gt;Deploying our first API&lt;/h1&gt;
&lt;p&gt;If we had containerized our API with Docker, Railway would have been perfectly happy for us to give it a dockerfile, and it would deploy that no problem. However, Railway also supports building and deploying .NET apps without needing to containerize them. Let's do that first, since we're trying to keep things barebones to get started.&lt;/p&gt;
&lt;h2&gt;Deploying From a GitHub Repo&lt;/h2&gt;
&lt;p&gt;One of Railway's coolest features is that you can start a project off by pointing it at a GitHub repo, and it'll automatically (ish) deploy the repo, and set up hooks to listen to any changes on &lt;code&gt;master&lt;/code&gt; and deploy then.&lt;/p&gt;
&lt;h3&gt;Configuring the Repository for Deployment&lt;/h3&gt;
&lt;p&gt;After logging in, we should be faced with a big New Project button&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-new-project.png" alt="New Project button in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;Here we'll select Deploy from GitHub repo&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-new-project-select-github.png" alt="Select GitHub in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;And then we can select the repo we just pushed&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-new-project-select-repo.png" alt="Select Repo in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;And why not try deploying right off the bat, so long as it's giving us the option?&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-new-project-deploy-repo.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;We should see the deployment fail in just a few seconds.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-deploy-first-fail.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;h3&gt;Debugging the First Errors&lt;/h3&gt;
&lt;p&gt;Let's click on the deployment and inspect the deploy logs. The first thing to notice is that Railway actually did a really good job guessing what our build config should be. At the top of the logs, we can see:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt; setup      │ dotnet-sdk                                    
────────────────────────────────────────────────────────────
 install    │ dotnet restore                                
────────────────────────────────────────────────────────────
 build      │ dotnet publish --no-restore -c Release -o out 
────────────────────────────────────────────────────────────
 start      │ ./out/RailwayAspApiDemo                       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's really spectacular! Just because we had a &lt;code&gt;.csproj&lt;/code&gt; file, it was able to fill this all out. But it's not all peaches and pringles, we've got a build error. And indeed we're able to see a failure just a few lines down:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;#10 1.426 /nix/store/832ihvqk3vxgqqs5hvcyvg6bxqybky14-dotnet-sdk-6.0.403/sdk/6.0.403/Sdks
          /Microsoft.NET.Sdk/targets/Microsoft.NET.TargetFrameworkInference.targets(144,5):
          error NETSDK1045: The current .NET SDK does not support targeting .NET 7.0.
          Either target .NET 6.0 or lower, or use a version of the .NET SDK
          that supports .NET 7.0. [/app/RailwayAspApiDemo.csproj]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Classic cloud moment - we need to know how to configure the .NET SDK version. Thankfully, &lt;a href="https://nixpacks.com/docs/providers/csharp"&gt;Railway's docs&lt;/a&gt;, though sparse, do give us exactly what we need, an environment variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;NIXPACKS_CSHARP_SDK_VERSION=&amp;quot;7.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can be set on the &lt;code&gt;Variables&lt;/code&gt; tab on the UI for the service:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-variables-sdk-version.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;Adding that variable should reschedule the deployment. Indeed, it works!&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-deploy-second-success.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;Just one thing - how do we see it? We'll need to generate a domain ourselves in the &lt;code&gt;Settings&lt;/code&gt; tab in the UI for the service:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-settings-networking.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;That will generate a slightly random &lt;code&gt;.up.railway.app&lt;/code&gt; domain for you to get started with. Of course, you can add a custom domain here if you've purchased one, but I'm going to roll with this because somehow I managed to snag &lt;a href="http://railwayaspapidemo-production.up.railway.app"&gt;railwayaspapidemo-production.up.railway.app&lt;/a&gt;. Luky me!&lt;/p&gt;
&lt;p&gt;Now we can navigate to that link and see &amp;quot;Hello, World!&amp;quot; right?&lt;/p&gt;
&lt;p&gt;Right?&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-failed-respond.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;Well, the build deployed, so let's look at our deploy logs. I imagine yours will look similar to mine:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;info: Microsoft.Hosting.Lifetime[14]
Now listening on: http://0.0.0.0:3000
info: Microsoft.Hosting.Lifetime[0]
Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
Content root path: /app
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It says it's listening on port 3000, so it seems like the app is running, but why can't we see it? That's because when Railway deploys our app, it deploys it in a Docker container and generates a port for us. That means we either need to wire our app up to listen on the port that Railway dictates, or we need to tell Railway to use our nice, pretty port 3000. Luckily, Railway allows us to do both; the port number lives in the environment variable &lt;code&gt;PORT&lt;/code&gt;, so we can either override that in Railway or consume the environment variable from our API.&lt;/p&gt;
&lt;h3&gt;Overriding Railway's Port Assignment&lt;/h3&gt;
&lt;p&gt;To override Railway's port assignment, we can just set the environment variable in the variables tab, just like how we set the &lt;code&gt;NIXPACKS_CSHARP_SDK_VERSION&lt;/code&gt; variable earlier:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;PORT=&amp;quot;3000&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will trigger a redeploy, and then we'll cross our fingers, refresh the app, and...&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-hello-world-success.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;Nice!&lt;/p&gt;
&lt;h3&gt;Using Railway's Port in our API&lt;/h3&gt;
&lt;p&gt;Alternatively, if you want to use the Railway-generated port, we can add just a bit of code to do that. Go ahead and delete the &lt;code&gt;PORT&lt;/code&gt; environment variable if you added that.&lt;/p&gt;
&lt;p&gt;We can update our &lt;code&gt;Program.cs&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(args);

if (Environment.GetEnvironmentVariable(&amp;quot;PORT&amp;quot;) is not null and string environmentPort
    &amp;amp;&amp;amp; int.TryParse(environmentPort, out int port))
{
    builder.WebHost.ConfigureKestrel(o =&amp;gt; o.ListenAnyIP(port));
}

var app = builder.Build();

app.MapGet(&amp;quot;/&amp;quot;, () =&amp;gt; &amp;quot;Hello World!&amp;quot;);

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Aside: I &lt;strong&gt;hate&lt;/strong&gt; the syntax &lt;code&gt;is not null and string&lt;/code&gt; but I'm not going to complain. Too much.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Push that code to master and you should see Railway start deploying your API right away. Once that's up, you should see &amp;quot;Hello, World!&amp;quot; in the browser at your app.&lt;/p&gt;
&lt;h2&gt;Deploy From Docker or CLI&lt;/h2&gt;
&lt;p&gt;I could type out a whole section here, but honestly I would just be copying &lt;a href="https://rendle.dev/posts/deploying-to-railway-with-dotnet/"&gt;Mark Rendle's excelent explanation&lt;/a&gt;. His tutorial was quite helpful for me getting started, and I'd like to give some credit where it's due. So, if you want to containerize your app and use the dockerfile instead of Railway's build steps, or if you want to deploy using Railway's CLI, please give his article a visit!&lt;/p&gt;
&lt;h1&gt;Deploying a Blazor App&lt;/h1&gt;
&lt;p&gt;We've got our barebones API up and running, but it's missing a number of things yet. Frankly, that's a trivial example that's hiding a number of problems that still exist. I think Blazor's a good way to demonstrate these, especially since an ASP.NET-hosted Blazor WASM project requires sharing static files.&lt;/p&gt;
&lt;h2&gt;Setting up a Blazor Project&lt;/h2&gt;
&lt;p&gt;Similar to the API we created above, we can get the default Blazor project initialized with&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;dotnet new blazorwasm --hosted -n RailwayBlazorDemo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will create an &amp;quot;ASP.NET-hosted&amp;quot; Blazor app, which means we'll get a separate client and server project. Go ahead and run this locally - it will spin up the server, and the server will serve you the Blazor WASM client at root:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-blazor-default.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;Go ahead and push this to a new repository (for reference you can &lt;a href="https://github.com/IanWold/RailwayBlazorDemo"&gt;see mine here&lt;/a&gt;) and create a new project in Railway, linking to this new repository.&lt;/p&gt;
&lt;p&gt;That should start a deploy like before, and just like before you'll get a failed build. Remember to set the &lt;code&gt;NIXPACKS_CSHARP_SDK_VERSION&lt;/code&gt; environment variable, and resolve the port issue however you choose. I'll choose to resolve it in my code. In order to do that, I'll edit the &lt;code&gt;/Server/Program.cs&lt;/code&gt; file with the same lines we added to the barebones API. While that deploys, we also need to generate a domain for this app like we did before. And, don't you know it, I got lucky again: &lt;a href="http://railwayblazordemo-production.up.railway.app"&gt;railwayblazordemo-production.up.railway.app&lt;/a&gt;! Neat.&lt;/p&gt;
&lt;h3&gt;Configuring Railway to Deploy the Server&lt;/h3&gt;
&lt;p&gt;At this point, we might expect it to work. However, you'll notice after building Railway attempts to start the service several times, but fails with the same message:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;/bin/bash: line 1: ./out/RailwayBlazorDemo.Client: No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Uh oh - we don't want to deploy the &lt;em&gt;client&lt;/em&gt;, we want to deploy the &lt;em&gt;server&lt;/em&gt;, because the server is configured to serve the client. The cause of this can be seen in the build logs like we'd expect - the automagic build figurer-outer guessed that we wanted to deploy the client:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;setup      │ dotnet-sdk_7                                  
───────────────────────────────────────────────────────────
install    │ dotnet restore                                
───────────────────────────────────────────────────────────
build      │ dotnet publish --no-restore -c Release -o out 
───────────────────────────────────────────────────────────
start      │ ./out/RailwayBlazorDemo.Client                
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This, like the other environment configuration issues in Railway, is simple to resolve. If you navigate back to the &lt;code&gt;Settings&lt;/code&gt; tab on the UI for the service, scroll down and you'll see Deploy settings, with a helpful place to override the start command. In fact you can override any of the build steps in these settings, although you'll notice that they're pretty sparse. For our needs here though, those settings are all fine, so we'll just update the start command to &lt;code&gt;./out/RailwayBlazorDemo.Server&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-settings-start-command.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;p&gt;This will trigger a rebuild, and that should succeed! Our app should now be at the address we generated earlier, right?&lt;/p&gt;
&lt;p&gt;Right?&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-failed-404.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;h3&gt;Configuring the ContentRootPath&lt;/h3&gt;
&lt;p&gt;Well, that's interesting, because it's a different error than we got when first deploying the barebones API earlier. In that case, we got a nice error displayed with Railway's UI. This tells us that the server is up and running - of course though we verified that when the server started logging after it deployed a minute ago. Thus, we know that the problem is with the server being able to serve up the client app.&lt;/p&gt;
&lt;p&gt;What's going on here isn't entirely obvious and it relies on a bit of knowledge about Docker to be able to intuit what's going on. There are two key lines in the logs. The key line is in the deploy logs:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plaintext"&gt;Content root path: /app
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What's going on is that the client is stored as a static file on the server, and the server needs access to that file to be able to serve it, of course. ASP calls the root directory for static files the &amp;quot;content root path&amp;quot;, and this one is a bit bunked.&lt;/p&gt;
&lt;p&gt;This has a code solution. Replace the first line of &lt;code&gt;Server/Program.cs&lt;/code&gt; with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = WebApplication.CreateBuilder(new WebApplicationOptions() {
    Args = args,
    ContentRootPath = &amp;quot;./&amp;quot;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Yes, &lt;code&gt;ContentRootPath&lt;/code&gt; is &lt;em&gt;supposed&lt;/em&gt; to default to its root directory, but there's some weirdness that got introduced ... &lt;em&gt;*checks notes*&lt;/em&gt; ... somewhere? Honestly, I'm not sure how this solves it - I've just debugged enough weird directory issues with Docker in my professional career that it triggered my spidey senses.&lt;/p&gt;
&lt;p&gt;Making that change and pushing to &lt;code&gt;master&lt;/code&gt; will trigger a rebuild. Then, as if by magic, our app is working at the link:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/IanWold/ianwold.github.io/master/Static/images/deploy-railway-blazor-success.png" alt="Deploy Repo in Railway" /&gt;&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Despite a few bumps in the road (which, apart from the content root path issue, make sense in context) we were able to get two .NET apps deployed in no time and with no money! In future, I think we'll explore adding a database with Railway and hooking our Blazor app up to it.&lt;/p&gt;
&lt;p&gt;I think this is the sort of case where Railway really excells. If you don't have an overly complicated backend system, deploying with Railway is extremely fast, simple, and cheap. Their focus on this area significantly reduces the barrier to entry to get a hobby app out the door. And, it seems that Railway does have enough capability to scale if you do attract users - at least through the first phase or two. Because of these factors, I'll be using Railway to deploy all my hobby apps in the future here! I'm very excited to discover a cloud provider this capable at this price.&lt;/p&gt;
&lt;p&gt;Railway's limitations are very apparent though - such is the tradeoff with the simplicity they've achieved. While you certainly can deploy any container with Railway, an overly complicated backend system could potentially become more burdensome to maintain than not. Really though, I don't know where that boundary is, but I suspect it's decently high enough that even if I do take some pet projects into production properly, I can rely on Railway to be able to serve them adequately.&lt;/p&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;p&gt;You can see my GitHub repos used in this article here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/IanWold/RailwayAspApiDemo"&gt;RailwayAspApiDemo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/IanWold/RailwayBlazorDemo"&gt;RailwayBlazorDemo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://docs.railway.app/"&gt;Railway's documentation&lt;/a&gt; is pretty good, but their &lt;a href="https://discord.com/invite/railway"&gt;Discord server&lt;/a&gt; is an excellent and lively place to get help when you need it.&lt;/p&gt;
</description><a10:updated>2023-09-05T00:00:00Z</a10:updated></item><item><guid isPermaLink="false">sprache</guid><link>https://ian.wold.guru/Posts/sprache.html</link><title>An Introduction to Sprache</title><description>&lt;p&gt;As my activity on this blog and my GitHub account may attest, I'm quite fond of a C# library called Sprache. Sprache is a parser-combinator that uses LINQ (Language INtegrated Query) to allow for the elegant construction of parsers in C#. I've been using Sprache for three years now, before I started college, and I've used it to implement a number of domain-specific languages (DSLs) both in side projects on my GitHub and on applications I've worked on. It's only natural I would want to share my favorite C# library with my fellow undergraduate classmates, but there are several factors which make it rather unapproachable for the average undergraduate computer science student. Thus, I have written this piece to provide a completely introductory tutorial to using Sprache.&lt;/p&gt;
&lt;p&gt;I'll explain LINQ and BNF, and then I'll walk you through the implementation of a few simple grammars in Sprache such that I may touch upon all the most important concepts in the Sprache library to allow the reader to immediately begin to implement the grammars which they desire. At the end of this post, I link to several articles which cover the framework and other related readings. In the future, I may also write a short handbook/reference to certain Sprache concepts.&lt;/p&gt;
&lt;p&gt;One does not necessarily need to have an understanding of C# to begin using Sprache, but a familiarity of a similar language (i.e. Java) would go a long way. I'm going to assume the reader has an understanding of object-oriented programming. I won't be going into an explanation of what a parser-combinator is, nor what a &amp;quot;combinator&amp;quot; is, in general. If you would like to become more involved in the development of Sprache, though, you should definitely familiarize yourself with the concept. I provide some links at the end of this tutorial to that end.&lt;/p&gt;
&lt;h1&gt;Prerequisites&lt;/h1&gt;
&lt;p&gt;To begin with, of course, you'll need to download Sprache. You can find it &lt;a href="https://github.com/sprache/Sprache"&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;LINQ&lt;/h2&gt;
&lt;p&gt;LINQ, short for Language INtegrated Query, is a wonderful feature of Visual C# which adds data-querying operators to C#. LINQ expressions are sometimes (grammatically incorrectly) referred to as &amp;quot;LINQ queries&amp;quot; as they read rather fluently as a query on a data set. Here is an example of a LINQ expression:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;var myList = new List&amp;lt;string&amp;gt;()
{
    &amp;quot;hello&amp;quot;,
    &amp;quot;world&amp;quot;,
    &amp;quot;how&amp;quot;,
    &amp;quot;are&amp;quot;,
    &amp;quot;you&amp;quot;
};

var startsWithH =
    from s in myList
    where s.ToCharArray()[0] == 'h'
    select s;

foreach (var a in startsWithH)
	Console.WriteLine(a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we start with a list of words, and we desire to print to the console each word which begins with the letter 'h'. The variable &lt;em&gt;startsWithH&lt;/em&gt; is defined with the following LINQ expression, which is how we sort out those words which start with 'h':&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;from s in myList
where s.ToLower().ToCharArray()[0] == 'h'
select s;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's look at what's going on here. First, we have a &lt;em&gt;from&lt;/em&gt; statement. This will iterate over each object in &lt;em&gt;myList&lt;/em&gt;, using &lt;em&gt;s&lt;/em&gt; as the iterator variable. Next, we have a &lt;em&gt;where&lt;/em&gt; statement, which filters out the objects in &lt;em&gt;myList&lt;/em&gt; based on the condition provided. Note that several &lt;em&gt;where&lt;/em&gt; statements could be specified here. At the end of this LINQ expression, as with every LINQ expression, we have a &lt;em&gt;select&lt;/em&gt; statement, which returns each &amp;quot;queried&amp;quot; object. In this case, we only desire to return the strings which begin with the letter 'h'.&lt;/p&gt;
&lt;p&gt;LINQ supports several operators apart from &lt;em&gt;from&lt;/em&gt;, &lt;em&gt;where&lt;/em&gt;, and &lt;em&gt;select&lt;/em&gt;, though these are the main ones. Microsoft, naturally, provides a very in-depth &lt;a href="https://msdn.microsoft.com/en-us/library/bb394939.aspx"&gt;list of LINQ operators&lt;/a&gt;, though Wikipedia has &lt;a href="https://en.wikipedia.org/wiki/Language_Integrated_Query#Standard_Query_Operators"&gt;a much more succinct list&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Sprache uses LINQ to construct its parsers. This allows for quick implementation and easy and intuitive readability.&lt;/p&gt;
&lt;h2&gt;Backus-Naur Form&lt;/h2&gt;
&lt;p&gt;Backus-Naur Form, or BNF for short, is a metalanguage used to describe the grammars and syntax of context-free grammars (essentially, for our purposes, this means the grammars of computing languages). BNF defines expressions in terms of other expressions and strings using a number of rules which will become more familiar as we begin implementing these grammars in Sprache.&lt;/p&gt;
&lt;p&gt;As an example, suppose I want to define a grammar which specifies an arithmetic expression which might add, subtract, multiply, or divide two digits. I'll provide a BNF definition of this grammar, and then explain it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bnf"&gt;&amp;lt;expr&amp;gt;      ::= &amp;lt;add&amp;gt; | &amp;lt;subtract&amp;gt; | &amp;lt;multiply&amp;gt; | &amp;lt;divide&amp;gt;

&amp;lt;add&amp;gt;       ::= &amp;lt;digit&amp;gt; &amp;quot;+&amp;quot; &amp;lt;digit&amp;gt;
&amp;lt;subtract&amp;gt;  ::= &amp;lt;digit&amp;gt; &amp;quot;-&amp;quot; &amp;lt;digit&amp;gt;
&amp;lt;multiply&amp;gt;  ::= &amp;lt;digit&amp;gt; &amp;quot;*&amp;quot; &amp;lt;digit&amp;gt;
&amp;lt;divide&amp;gt;    ::= &amp;lt;digit&amp;gt; &amp;quot;/&amp;quot; &amp;lt;digit&amp;gt;

&amp;lt;digit&amp;gt;     ::= &amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; | &amp;quot;4&amp;quot; | &amp;quot;5&amp;quot; | &amp;quot;6&amp;quot; | &amp;quot;7&amp;quot; | &amp;quot;8&amp;quot; | &amp;quot;9&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's look at each of the elements and what they do. First, the most notable and important element is the reference for an expression, which looks like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bnf"&gt;&amp;lt;expression_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The expressions are referenced by this convention, and they are defined with the &lt;em&gt;::=&lt;/em&gt; operator. In defining such expressions, a number of rules can be used. Look at the definition for &lt;em&gt;expr&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bnf"&gt;&amp;lt;expr&amp;gt;      ::= &amp;lt;add&amp;gt; | &amp;lt;subtract&amp;gt; | &amp;lt;multiply&amp;gt; | &amp;lt;divide&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The bar ('|') denotes an &lt;em&gt;or&lt;/em&gt; relationship. That is, an expression &lt;em&gt;expr&lt;/em&gt; can be either an &lt;em&gt;add&lt;/em&gt;, &lt;em&gt;subtract&lt;/em&gt;, &lt;em&gt;multiply&lt;/em&gt;, or &lt;em&gt;divide&lt;/em&gt; expression.&lt;/p&gt;
&lt;p&gt;Now let's look at the definition of the &lt;em&gt;add&lt;/em&gt; expression:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bnf"&gt;&amp;lt;add&amp;gt;       ::= &amp;lt;digit&amp;gt; &amp;quot;+&amp;quot; &amp;lt;digit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This specifies that an &lt;em&gt;add&lt;/em&gt; can be a &lt;em&gt;digit&lt;/em&gt;, followed by a plus sign, followed by another &lt;em&gt;digit&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;You might notice a bit of an inefficiency in the grammar I defined above. Namely, we define &lt;em&gt;add&lt;/em&gt;, &lt;em&gt;subtract&lt;/em&gt;, &lt;em&gt;multiply&lt;/em&gt;, and &lt;em&gt;divide&lt;/em&gt; separately, but due to the similarity in their structures, it feels like we should be able to define them all together. While there are certainly good reasons one might want to define them separately as I did above, for succinctness one might desire to redefine the grammar as such:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bnf"&gt;&amp;lt;expr&amp;gt;      ::= &amp;lt;digit&amp;gt; (&amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;*&amp;quot; | &amp;quot;/&amp;quot;) &amp;lt;digit&amp;gt;

&amp;lt;digit&amp;gt;     ::= &amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; | &amp;quot;4&amp;quot; | &amp;quot;5&amp;quot; | &amp;quot;6&amp;quot; | &amp;quot;7&amp;quot; | &amp;quot;8&amp;quot; | &amp;quot;9&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here I introduce a grouping of terms, defined by the parentheses. Now, &lt;em&gt;expr&lt;/em&gt; is defined to be two &lt;em&gt;digits&lt;/em&gt; separated by either an addition, subtraction, multiplication, or division symbol. This is, however, a rather dumb grammar, in that only two &lt;em&gt;digits&lt;/em&gt; can be used in the arithmetic expression, while we might want to allow any number to be used. We can extend the grammar further to allow for this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bnf"&gt;&amp;lt;expr&amp;gt;      ::= &amp;lt;number&amp;gt; (&amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;*&amp;quot; | &amp;quot;/&amp;quot;) &amp;lt;number&amp;gt;

&amp;lt;number&amp;gt;    ::= &amp;lt;integer&amp;gt; [&amp;quot;.&amp;quot; &amp;lt;integer&amp;gt;]
&amp;lt;integer&amp;gt;   ::= +(&amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; | &amp;quot;4&amp;quot; | &amp;quot;5&amp;quot; | &amp;quot;6&amp;quot; | &amp;quot;7&amp;quot; | &amp;quot;8&amp;quot; | &amp;quot;9&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we have broken a number into two parts, a &lt;em&gt;number&lt;/em&gt; and an &lt;em&gt;integer&lt;/em&gt;. Where I define &lt;em&gt;integer&lt;/em&gt;, I introduce a plus sign, which allows the expression which it suffixes to be repeated one or more times. Where I define &lt;em&gt;number&lt;/em&gt;, I introduce the square brackets, which surround optional expressions. Thus, the following terms are captured by the expression &lt;em&gt;number&lt;/em&gt;: 0, 125, 3.14, and 123.456. However, the following terms are not captured by &lt;em&gt;number&lt;/em&gt;, and I will allow the reader to postulate why they are not, and how the grammar might need to be altered to capture them: .31, -12, -12.56, and -.987.&lt;/p&gt;
&lt;p&gt;When we want to parse a language with Sprache (or any other parser, for that matter), we will first define the language in BNF, so that we can easily reference the pieces of the parser we must create, and to keep track of our progress.&lt;/p&gt;
&lt;h1&gt;Sprache&lt;/h1&gt;
&lt;p&gt;Ultimately, once you get used to using LINQ to construct parsers, Sprache is just another library, and becoming proficient in Sprache is the same process one should be used to of learning the methods given by the library and learning how to ask questions on stack overflow.&lt;/p&gt;
&lt;p&gt;Let's begin familiarizing ourselves by constructing a parser which can parse the string &amp;quot;hello&amp;quot; into a string &amp;quot;hello.&amp;quot; This is an entirely non-useful task for Sprache, but it gets our feet wet:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;string&amp;gt; myParser =
    from str in Parse.String(&amp;quot;hello&amp;quot;).Text()
    select str;

string val = myParser.Parse(&amp;quot;hello&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;val&lt;/em&gt; will, unremarkably, be &amp;quot;hello.&amp;quot;However, the parser should be very easy to understand, especially given our understanding of the working of a LINQ expression. The method &lt;em&gt;String(string)&lt;/em&gt; is a parser which parses any string you desire (in this case, we desired to parse the string &amp;quot;hello&amp;quot;). The &lt;em&gt;String&lt;/em&gt; parser returns an enumerable of chars, so we need to use &lt;em&gt;Text&lt;/em&gt; to turn the enumerable into a string. From there, it should be rather obvious what is going on.&lt;/p&gt;
&lt;p&gt;Now, let's suppose we want to parse the string &amp;quot;hello&amp;quot; multiple times, separated by whitespace, and we want to know how many times &amp;quot;hello&amp;quot; appears. We can extend our parser above like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;int&amp;gt; myParser =
    from str in
        Parse.String(&amp;quot;hello&amp;quot;).Text()
        .DelimitedBy(Parse.WhiteSpace.Many())
    select str.Count();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Testing this parser with the string &amp;quot;hello   hellohello  hello&amp;quot; should return a result of 4. Because of the way our parser is constructed, it is relatively straightforward to read it as &amp;quot;parse the string &amp;quot;hello&amp;quot; delimited by whitespace.&amp;quot; But let's look at what's going on here. &lt;em&gt;DelimitedBy&lt;/em&gt; will attempt to match the &amp;quot;hello&amp;quot; parser, and then it will look for whitespace (&lt;em&gt;WhiteSpace().Many()&lt;/em&gt; is a parser itself which matches 0 or more different whitespace characters in a row), and will then look to match &amp;quot;hello&amp;quot; again and more whitespace, until the parser is no longer able to match either &amp;quot;hello&amp;quot; or whitespace, at which point it returns an &lt;em&gt;IEnumberable&lt;/em&gt; containing several &amp;quot;hello&amp;quot;s. Our &lt;em&gt;select&lt;/em&gt; statement can then select the &lt;em&gt;Count&lt;/em&gt; of that &lt;em&gt;IEnumerable&lt;/em&gt;, and thus we can obtain the number of times &amp;quot;hello&amp;quot; is parsed.&lt;/p&gt;
&lt;p&gt;This idea of chaining parsers onto each other, as &lt;em&gt;DelimitedBy&lt;/em&gt; is chained onto &lt;em&gt;String&lt;/em&gt;, is the entire concept behind parser-combinators.&lt;/p&gt;
&lt;p&gt;A slightly more complicated task might be to try to parse a variable name surrounded by whitespace (often called an &amp;quot;identifier&amp;quot;). This example is given on the Sprache GitHub page:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;string&amp;gt; identifier =
    from leading in Parse.WhiteSpace.Many()
    from first in Parse.Letter.Once()
    from rest in Parse.LetterOrDigit.Many()
    from trailing in Parse.WhiteSpace.Many()
    select new string(first.Concat(rest).ToArray());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus, &amp;quot;   abc123   &amp;quot; should come out as &amp;quot;abc123&amp;quot;. Notice how staggering several &lt;em&gt;from&lt;/em&gt; statements in a row reads as though we are saying &amp;quot;then&amp;quot;. For example, this parser could be read by a human as &amp;quot;Parse many whitespace characters, &lt;em&gt;then&lt;/em&gt; parse one letter, &lt;em&gt;then&lt;/em&gt; parse 0 or more letters or digits, &lt;em&gt;then&lt;/em&gt; parse more whitespace, and return the first letter and the rest of the letters/digits concatenated to it&amp;quot;.&lt;/p&gt;
&lt;h2&gt;Our First Language&lt;/h2&gt;
&lt;p&gt;So, let's now define the grammar for a small DSL, and we'll try to parse it. Let's make a language that defines variables: we can have an identifier, followed by a colon, and then a string, and we can define as many variables as we want on different lines. Ultimately, we want to parse this into a dictionary. So, our resulting language could look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;identifier1 : &amp;quot;hello&amp;quot;
identifier2 : &amp;quot;world&amp;quot;
identifier3 : &amp;quot;yay parsing&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The BNF for the language looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-BNF"&gt;&amp;lt;block&amp;gt;        ::= &amp;lt;expr&amp;gt; *(&amp;lt;newline&amp;gt; &amp;lt;expr&amp;gt;)
&amp;lt;expr&amp;gt;         ::= &amp;lt;identifier&amp;gt; [&amp;lt;whitespace&amp;gt;] &amp;quot;:&amp;quot; [&amp;lt;whitespace&amp;gt;] &amp;lt;string&amp;gt;
&amp;lt;identifier&amp;gt;   ::= &amp;lt;letter&amp;gt; *(&amp;lt;letter&amp;gt; | &amp;lt;digit&amp;gt;)
&amp;lt;string&amp;gt;       ::= &amp;quot;\&amp;quot;&amp;quot; *(&amp;lt;any_character&amp;gt;) &amp;quot;\&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I'll imagine you can determine what &lt;em&gt;newline&lt;/em&gt;, &lt;em&gt;letter&lt;/em&gt;, &lt;em&gt;digit&lt;/em&gt;, and &lt;em&gt;any_character&lt;/em&gt; are. Note, though, that we technically want &lt;em&gt;any_character&lt;/em&gt; to parse any character except a quotation mark.&lt;/p&gt;
&lt;p&gt;Sprache already contains parsers for a letter, digit, and any character, so we should be all good to go from here. We already have our identifier parser, so let's add to that by constructing our string parser:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;string&amp;gt; identifier =
    from first in Parse.Letter.Once()
    from rest in Parse.LetterOrDigit.Many()
    select new string(first.Concat(rest).ToArray());

Parser&amp;lt;string&amp;gt; stringParser =
    from first in Parse.Char('&amp;quot;')
    from text in Parse.AnyChar.Except(Parse.Char('&amp;quot;')).Many().Text()
    from last in Parse.Char('&amp;quot;')
    select text;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we use &lt;em&gt;Except&lt;/em&gt; to add an exception to the &lt;em&gt;AnyChar&lt;/em&gt; parser. In addition, we use &lt;em&gt;Text&lt;/em&gt; at the end to tell sprache to convert the IEnumerable returned by &lt;em&gt;Many&lt;/em&gt; into a string. Now, we can add the parser for the expressions:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;//Adding to the code above:

Parser&amp;lt;Dictionary&amp;lt;string, string&amp;gt;&amp;gt; expr =
    from id in identifier
    from colon in Parse.Char(':').Token()
    from str in stringParser
    select new Dictionary&amp;lt;string, string&amp;gt;() { { id, str } };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt; is used here - that does exactly what it says - it makes the parser optional. In addition, I introduced &lt;em&gt;Token&lt;/em&gt;, which will parse whitespace before and after the &lt;em&gt;CHar&lt;/em&gt; parser. Notice how we are able to reference the parsers we created earlier, and we can use the values they return to create a new object. Let's finish it off by creating the &amp;quot;block&amp;quot; parser, which is supposed to parse several expressions separated by newlines:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;//Adding to the code above:

Parser&amp;lt;IEnumerable&amp;lt;Dictionary&amp;lt;string,string&amp;gt;&amp;gt;&amp;gt; block =
    expr.DelimitedBy(Parse.Char('\n'));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice  how we are not using the fancy LINQ expressions here. Because our parser fits on one line, and &lt;em&gt;DelimitedBy&lt;/em&gt; returns the type that we want, then we can condense our parser a bit. Now that we're done with our parser, we should be able to parse our example file just fine into an &lt;em&gt;IEnumberable&lt;/em&gt; of dictionaries containing our identifier-string pairs.&lt;/p&gt;
&lt;h2&gt;Comma-Separated Values&lt;/h2&gt;
&lt;p&gt;CSV files are extremely popular for storing tables in plaintext, and they're very easy to parse, as you might imagine. Frequently, programs which read from CSV files desire to read the files into their own data structures. So, we'll imagine a couple different scenarios involving CSVs, and we'll look at how we can go about parsing each one.&lt;/p&gt;
&lt;p&gt;First, I'll provide a rough CSV parser that sorts the CSV into a list of a list of strings, and from there we can talk about a custom data structure for it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;IEnumerable&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&amp;gt; csv = 
    Parse.AnyChar.Except(Parse.Char(',')
        .Or(Parse.Char('\n'))).Many().Text()
        .DelimitedBy(Parse.Char(',').Token())
        .DelimitedBy(Parse.Char('\n'));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This parser is quite fun, as it can be written in one line, yet it parses a CSV file pretty much alright - you might notice that none of the values can contain a comma (Bonus problem: see if you can get the parser to recognize escape characters so that the user can insert commas. Later, in the JSON parser, we'll implement escape characters).&lt;/p&gt;
&lt;p&gt;Let's digress now, and suppose we have the following simplistic data structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;class Row
{
    public string Title { get; set; }
    public IEnumerable&amp;lt;string&amp;gt; Items { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And let's further suppose that in a CSV, the first item of every row is the title of that row, and the remaining elements in that row are the items, corresponding to the structure above. So, we want to get a list of these rows, presumably. We can very easily modify our parser:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;Row&amp;gt; line =
    from first in
        Parse.AnyChar
        .Except(Parse.Char(',')
        .Or(Parse.Char('\n')))
        .Many().Text()
    from comma in Parse.Char(',').Token()
    from rest in
        Parse.AnyChar
        .Except(Parse.Char(',')
        .Or(Parse.Char('\n'))).Many().Text()
        .DelimitedBy(Parse.Char(',').Token())
    select new Row() { Title = first, Items = rest };

Parser&amp;lt;IEnumerable&amp;lt;Row&amp;gt;&amp;gt; csv = line.DelimitedBy(Parse.Char('\n'));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Naturally, if you're just interested in obtaining the rows, then this parser works perfectly. But let's suppose we didn't want the nested lists to contain the rows, but the columns. In this case, we can do some nifty snafu:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; line =
    Parse.AnyChar.Except(Parse.Char(',')
        .Or(Parse.Char('\n'))).Many().Text()
        .DelimitedBy(Parse.Char(',').Token());

Parser&amp;lt;IEnumerable&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&amp;gt; csv =
    from l in line.DelimitedBy(Parse.Char('\n'))
    select Transform(l);

//Here's the Transform method:
//Assume the table is n-by-n
static IEnumerable&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Transform(IEnumerable&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; t)
{
    var toReturn = new List&amp;lt;List&amp;lt;string&amp;gt;&amp;gt;();
    
    for (int i = 0; i &amp;lt; t.ElementAt(0).Count(); i++)
    {
        for (int j = 0; j &amp;lt; t.Count(); j++)
        {
            if (toReturn.Count == i) toReturn.Add(new List&amp;lt;string&amp;gt;);
            if (toReturn[i].Count == j) toReturn[i].Add(&amp;quot;&amp;quot;);
            
            toReturn[i][j] = t.ElementAt(j).ElementAt(i);
        }
    }

    return toReturn;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Transform&lt;/em&gt; just rotates the list of lists as though it's a matrix, so we're not adding anything too special here. What if we wanted to do what we did above with the rows, but with the columns? Try modifying this code to do just that. Bonus points if you can eliminate &lt;em&gt;Transform&lt;/em&gt; and perform the transformation within the parser!&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
&lt;p&gt;Obviously, XML is a rather complex language, and a &lt;a href="http://www.w3.org/TR/REC-xml/"&gt;complete BNF specification&lt;/a&gt; is thus very large. Therefore, we'll be using a much simpler variation of XML, which we can see below:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bnf"&gt;&amp;lt;tag&amp;gt; ::= &amp;lt;single_line_tag&amp;gt; | &amp;lt;multi_line_tag&amp;gt;
&amp;lt;short_tag&amp;gt; ::= &amp;quot;&amp;lt;&amp;quot; &amp;lt;identifier&amp;gt; &amp;lt;whitespace&amp;gt; &amp;lt;attribute&amp;gt;* &amp;quot;/&amp;gt;&amp;quot;
&amp;lt;full_tag&amp;gt; ::= &amp;quot;&amp;lt;&amp;quot; &amp;lt;identifier&amp;gt; &amp;lt;whitespace&amp;gt; &amp;lt;attribute&amp;gt;* &amp;quot;&amp;gt;&amp;quot; &amp;lt;tag&amp;gt;*
    &amp;quot;&amp;lt;/&amp;quot; &amp;lt;identifier&amp;gt; &amp;quot;&amp;gt;&amp;quot;
&amp;lt;attribute&amp;gt; ::= &amp;lt;identifier&amp;gt; &amp;quot;=&amp;quot; &amp;quot;\&amp;quot;&amp;quot; &amp;lt;any_characters&amp;gt; &amp;quot;\&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might notice I'm leaving out a few unnecessary components: Expressions which are intuitively obvious aren't defined, &lt;em&gt;whitespace&lt;/em&gt; is only used where necessary (we'll use &lt;em&gt;Token&lt;/em&gt; prolifically to allow for flexibility on the user's part), and when defining a &amp;quot;full&amp;quot; tag, the identifier of the opening and closing tags must be the same. The latter component cannot be defined in vanilla BNF, so it's something we'll need to account for in our code.&lt;/p&gt;
&lt;p&gt;Instead of writing this code out, I'll reference the &lt;a href="https://github.com/sprache/Sprache/blob/master/src/XmlExample/Program.cs"&gt;XML example&lt;/a&gt; which is included with Sprache, and I'll explain the new elements and solutions found there.&lt;/p&gt;
&lt;p&gt;Right off the bat, looking at the &lt;em&gt;Document&lt;/em&gt; parser, we're introduced to a new use of LINQ. As I alluded to previously, any LINQ query can be written in one line without the LINQ statements. Here's the critical portion of line 98:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Node.Select(n =&amp;gt; new Document { Root = n })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To make this easier to comprehend, we can write it out using the regular LINQ notation we're familiar with:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;from n in Node
select new Document() { Root = n };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In fact, the LINQ statements we've been are just a shorthand (or perhaps more of a &amp;quot;paraphrasing,&amp;quot; as they tend to be longer) for the inline notation. &lt;em&gt;Document&lt;/em&gt;
very well could have been written using solely the LINQ statements, and that would have looked like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;public static readonly Parser&amp;lt;Document&amp;gt; Document =
    from leading in Parse.WhiteSpace.Many()
    from doc in from n in Node.End()
                select new Document() { Root = n }
    select doc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next parser up from &lt;em&gt;Document&lt;/em&gt; is &lt;em&gt;Item&lt;/em&gt;. We'll ignore the code regarding the comments (if you're interested in this, please see my post &lt;a href="https://ianwold.silvrback.com/parsing-comments-with-sprache"&gt;Parsing Comments with Sprache&lt;/a&gt;). This makes it easy to see that an &lt;em&gt;Item&lt;/em&gt; is either a &lt;em&gt;Node&lt;/em&gt; cast as an Item, or a &lt;em&gt;Content&lt;/em&gt;, and a &lt;em&gt;Node&lt;/em&gt; (looking above in the document) is either a short or full node.&lt;/p&gt;
&lt;p&gt;Looking at the &lt;em&gt;ShortNode&lt;/em&gt; parser, we can see it seems completely familiar, except that the LINQ expression is used as an argument to the &lt;em&gt;Tag&lt;/em&gt; method. The &lt;em&gt;Tag&lt;/em&gt; method returns a parser that parses a greater than and less than sign before and after the parser you specify. This abstraction allows us to write cleaner code.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FullNode&lt;/em&gt; is fun for a couple reasons. First, look at how they solved the issue of requiring opening and closing tags to be named the same with the &lt;em&gt;EndTag&lt;/em&gt; method. In addition, notice the use of the &lt;em&gt;Ref&lt;/em&gt; parser. In &lt;em&gt;FullNode&lt;/em&gt;, we need to use &lt;em&gt;Item&lt;/em&gt;, but it has obviously not yet been created. &lt;em&gt;Ref&lt;/em&gt; allows us to reference a parser later in the document, thus allowing us to create some recursive or ambiguous grammars with Sprache.&lt;/p&gt;
&lt;h2&gt;JSON&lt;/h2&gt;
&lt;p&gt;JSON, or JavaScript Object Notation, is kind of like XML. It's a way of storing data in plaintext (in a key-value pair manner) which is also easily readable by a human. In addition, it's very easy to construct a parser for it. The BNF form is very clear and concise - here, I have transcribed the &lt;a href="http://json.org/"&gt;informal definition on json.org&lt;/a&gt; into the more formal BNF notation which we have been using in this tutorial:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bnf"&gt;&amp;lt;object&amp;gt;    ::= &amp;quot;{}&amp;quot; | &amp;quot;{&amp;quot; &amp;lt;members&amp;gt; &amp;quot;}&amp;quot;
&amp;lt;members&amp;gt;   ::= &amp;lt;pair&amp;gt; | &amp;lt;pair&amp;gt; &amp;quot;,&amp;quot; &amp;lt;members&amp;gt;
&amp;lt;pair&amp;gt;      ::= &amp;lt;string&amp;gt; &amp;quot;:&amp;quot; &amp;lt;value&amp;gt;
&amp;lt;array&amp;gt;     ::= &amp;quot;[]&amp;quot; | &amp;quot;[&amp;quot; &amp;lt;elements&amp;gt; &amp;quot;]&amp;quot;
&amp;lt;elements&amp;gt;  ::= &amp;lt;value&amp;gt; | &amp;lt;value&amp;gt; &amp;quot;,&amp;quot; &amp;lt;elements&amp;gt;
&amp;lt;value&amp;gt;     ::= &amp;lt;literal&amp;gt; | &amp;lt;array&amp;gt; | &amp;lt;object&amp;gt;
&amp;lt;literal&amp;gt;   ::= &amp;lt;string&amp;gt; | &amp;lt;number&amp;gt; | &amp;lt;bool&amp;gt; | &amp;quot;null&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An example of a valid JSON file might be the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;firstName&amp;quot;: &amp;quot;John&amp;quot;,
  &amp;quot;lastName&amp;quot;: &amp;quot;Smith&amp;quot;,
  &amp;quot;age&amp;quot;: 25,
  &amp;quot;address&amp;quot;: {
    &amp;quot;streetAddress&amp;quot;: &amp;quot;21 2nd Street&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;,
    &amp;quot;state&amp;quot;: &amp;quot;NY&amp;quot;,
    &amp;quot;postalCode&amp;quot;: &amp;quot;10021-3100&amp;quot;
  },
  &amp;quot;phoneNumbers&amp;quot;: [
    {
      &amp;quot;type&amp;quot;: &amp;quot;home&amp;quot;,
      &amp;quot;number&amp;quot;: &amp;quot;212 555-1234&amp;quot;
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;office&amp;quot;,
      &amp;quot;number&amp;quot;: &amp;quot;646 555-4567&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This should allow us to construct the data structure we're going to store our data in (called an Abstract Syntax Tree):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;
public class JSONValue {}

public class JSONObject : JSONValue
{
    public Dictionary&amp;lt;string, JSONValue&amp;gt; Pairs { get; set; }

    public JSONObject(IEnumerable&amp;lt;KeyValuePair&amp;lt;string, JSONValue&amp;gt;&amp;gt; pairs)
    {
        Pairs = new Dictionary&amp;lt;string, JSONValue&amp;gt;();
        if (pairs != null)
            foreach (var p in pairs)
                Pairs.Add(p.Key, p.Value);
    }
}

public class JSONArray : JSONValue
{
    public List&amp;lt;JSONValue&amp;gt; Elements { get; set; }

    public JSONArray(IEnumerable&amp;lt;JSONValue&amp;gt; elements)
    {
        Elements = new List&amp;lt;JSONValue&amp;gt;();
        if (elements != null)
            foreach (var e in elements)
                Elements.Add(e);
    }
}

public class JSONLiteral : JSONValue
{
    public string Value { get; set; }

    public LiteralType ValueType { get; set; }

    public JSONLiteral(string value, LiteralType type)
    {
        Value = value;
        ValueType = type;
    }

    pubilc static enum LiteralType
    {
        String,
        Number,
        Boolean,
        Null
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To implement the parser, we'll start from the bottom and work our way up, as we usually do. Literal values are expressed nicely by our JSONLiteral class, which stores every value as a string, and also keeps track of the type of literal it is. Parsing them all out is a bit of a pain, so I'll post each parser here and explain it briefly.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;JSONLiteral&amp;gt; JNull =
    from str in Parse.IgnoreCase(&amp;quot;null&amp;quot;)
    select new JSONLiteral(null, JSONLiteral.LiteralType.Null);

Parser&amp;lt;JSONLiteral&amp;gt; JBoolean =
    from str in Parse.IgnoreCase(&amp;quot;true&amp;quot;).Text()
    			.Or(Parse.IgnoreCase(&amp;quot;false&amp;quot;).Text())
    select new JSONLiteral(str, LiteralType.Boolean);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parsing a literal null or boolean value isn't all too complicated. We just need to parse the strings which represent them, ignoring the case, and return new JSONLiteral objects.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;string&amp;gt; JExp =
    from e in Parse.IgnoreCase(&amp;quot;e&amp;quot;).Text()
    from sign in Parse.String(&amp;quot;+&amp;quot;).Text()
                 .Or(Parse.String(&amp;quot;-&amp;quot;).Text())
                 .Optional()
    from digits in Parse.Digit.Many().Text()
    select e + ((sign.IsDefined) ? sign.Get() : &amp;quot;&amp;quot;) + digits;

Parser&amp;lt;string&amp;gt; JFrac =
    from dot in Parse.String(&amp;quot;.&amp;quot;).Text()
    from digits in Parse.Digit.Many().Text()
    select dot + digits;

Parser&amp;lt;string&amp;gt; JInt =
    from minus in Parse.String(&amp;quot;-&amp;quot;).Text().Optional()
    from digits in Parse.Digit.Many().Text()
    select (minus.IsDefined ? minus.Get() : &amp;quot;&amp;quot;) + digits;

Parser&amp;lt;JSONLiteral&amp;gt; JNumber =
    from integer in JInt
    from frac in JFrac.Optional()
    from exp in JExp.Optional()
    select new JSONLiteral(integer +
                           (frac.IsDefined ? frac.Get() : &amp;quot;&amp;quot;) +
                           (exp.IsDefined ? exp.Get() : &amp;quot;&amp;quot;),
                           LiteralType.Number);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parsing a number is much more exciting. We need to account for integers, decimals, negation, and 'e'. The code above for &lt;em&gt;JNumber&lt;/em&gt; knows we need at least an integer, and can be optionally followed by the fraction or the exponential term. Notice that &lt;em&gt;Optional&lt;/em&gt; returns a special object which may or may not be defined. Thus, we need to check whether it is defined with &lt;em&gt;IsDefined&lt;/em&gt; before we can &lt;em&gt;Get&lt;/em&gt; its value.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;List&amp;lt;char&amp;gt; EscapeChars = new List&amp;lt;char&amp;gt;
    { '\&amp;quot;', '\\', 'b', 'f', 'n', 'r', 't' };

Parser&amp;lt;char&amp;gt; ControlChar =
    from first in Parse.Char('\\')
    from next in Parse.EnumerateInput(EscapeChars, c =&amp;gt; Parse.Char(c))
    select ((next == 't') ? '\t' :
            (next == 'r') ? '\r' :
            (next == 'n') ? '\n' :
            (next == 'f') ? '\f' :
            (next == 'b') ? '\b' :
            next );

Parser&amp;lt;char&amp;gt; JChar =
    Parse.AnyChar
    .Except(Parse.Char('&amp;quot;')
    .Or(Parse.Char('\\')))
    .Or(ControlChar);

Parser&amp;lt;JSONLiteral&amp;gt; JString =
    from first in Parse.Char('&amp;quot;')
    from chars in JChar.Many().Text()
    from last in Parse.Char('&amp;quot;')
    select new JSONLiteral(chars, LiteralType.String);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To parse a string, we want to make sure that we allow for control characters (the control characters are all given on &lt;a href="http://json.org"&gt;json.org&lt;/a&gt;). As you can see, the string will be zero or more characters, which are in turn any character except a quotation mark or the escape character. Where &lt;em&gt;ControlChar&lt;/em&gt; is defined, &lt;em&gt;EnumerateInput&lt;/em&gt; is used on our list &lt;em&gt;EscapeChars&lt;/em&gt;. This instance of &lt;em&gt;EnumerateInput&lt;/em&gt; will return the following parser:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parse.Char( '\&amp;quot;').Or(Parse.Char('\\')).Or(Parse.Char('b')) ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is, it chains each element in &lt;em&gt;EscapeChars&lt;/em&gt; along as the parser &lt;em&gt;Parse.Char()&lt;/em&gt; using the &lt;em&gt;Or&lt;/em&gt; parser.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;JSONLiteral&amp;gt; JLiteral =
    JString
    .XOr(JNumber)
    .XOr(JBoolean)
    .XOr(JNull);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we're able to piece them all together to form our &lt;em&gt;JLiteral&lt;/em&gt; parser. Luckily, this is half of our entire parser!&lt;/p&gt;
&lt;p&gt;As you can see from our JSON BNF, the rest of the grammar is recursive. That is, self-referential. This is where &lt;em&gt;Ref&lt;/em&gt; will come in handy. We need to implement objects and arrays, and those two &lt;strong&gt;plus&lt;/strong&gt; literals will be defined as a value. So, let's define our &lt;em&gt;JValue&lt;/em&gt; parser, and proceed from there.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;Parser&amp;lt;JSONValue&amp;gt; JValue =
    Parse.Ref(() =&amp;gt; JObject)
    .Or(Parse.Ref(() =&amp;gt; JArray))
    .Or(JLiteral);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we are using &lt;em&gt;Ref&lt;/em&gt; to reference our yet-undefined &lt;em&gt;JObject&lt;/em&gt; and &lt;em&gt;JArray&lt;/em&gt; parsers. Of course, we've already created our &lt;em&gt;JLiteral&lt;/em&gt; parser, so we do not need to use &lt;em&gt;Ref&lt;/em&gt; to access it.&lt;/p&gt;
&lt;p&gt;Now we just need to parse JSON arrays and objects. For convenience, let's recall the portion of the JSON BNF which defined them:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bnf"&gt;&amp;lt;object&amp;gt;    ::= &amp;quot;{}&amp;quot; | &amp;quot;{&amp;quot; &amp;lt;members&amp;gt; &amp;quot;}&amp;quot;
&amp;lt;members&amp;gt;   ::= &amp;lt;pair&amp;gt; | &amp;lt;pair&amp;gt; &amp;quot;,&amp;quot; &amp;lt;members&amp;gt;
&amp;lt;pair&amp;gt;      ::= &amp;lt;string&amp;gt; &amp;quot;:&amp;quot; &amp;lt;value&amp;gt;
&amp;lt;array&amp;gt;     ::= &amp;quot;[]&amp;quot; | &amp;quot;[&amp;quot; &amp;lt;elements&amp;gt; &amp;quot;]&amp;quot;
&amp;lt;elements&amp;gt;  ::= &amp;lt;value&amp;gt; | &amp;lt;value&amp;gt; &amp;quot;,&amp;quot; &amp;lt;elements&amp;g