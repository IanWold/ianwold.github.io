

	


<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<link rel="stylesheet" href="../site.css" />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		
			<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;800&display=swap&text=ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" rel="stylesheet">
			<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;600&family=Source+Code+Pro:wght@400&family=Vollkorn:wght@700&display=swap" rel="stylesheet">
		

		<link rel="webmention" href="https://webmention.io/ian.wold.guru/webmention" />

		<title>
			Ian Wold | An Introduction to Sprache 
		</title>

		
			<script type="application/ld+json">
				{
	"@context": "https://schema.org",
	"@type": "Article",
	"author": [{
		"@type": "Person",
		"name": "Ian Wold"
	}],
	"datePublished": "1/22/2016 12:00:00 AM",
	"image": "https://images.unsplash.com/photo-1494435658045-a657e4a01bcc",
	"headline": "An Introduction to Sprache",
	"description": "Sprache is a parser-combinator library for C# that uses Linq to construct parsers. In this post I describe the fundamentals of understanding grammars and parsing them with Sprache, with several real-world examples.",
	"publisher": {
		"@type": "Person",
		"name": "Ian Wold",
		"logo": {
			"@type": "ImageObject",
			"url": "https://ian.wold.guru/images/hero1.svg"
		}
	},
}
			</script>
		
	</head>
	<body>
		<button id="dark-mode-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></button>

		<nav class="content">
			<div class="headshot">
				<svg xmlns="http://www.w3.org/2000/svg" id="hero" height="165.41" width="150" viewBox="0 0 605 579"><path d="m485 574-1-5-4-2c-8 0-11-7-6-13 2-3 8-4 8-2l6 1c7-1 9 1 6 6l-4 5c-2 2-3 3-2 8 1 7-1 8-3 2zm-3-11c2-2 2-7-1-7l-1-2c0-2-1-2-3 1-3 2-3 6-1 8s2 2 6 0zm8-3c3-2 2-5-1-5-2 0-3 1-3 4s2 4 4 1zm-166 15-13-2c-1 1-8-1-17-2-8-2-22-4-30-4l-32-4c-25-4-46-5-49-2h-3c-2-3-22-4-40-1l-15 1c-1-1 2-2 9-3l9-3c1-1 0-1-6-1h-7c-1-1-6-2-14-1-16 0-19 0-19-2l12-2h-5c-14 0-20 1-25 2-9 3-9 3-9 1v-2l-8 2c-8 2-10 2-10 1 0-2 16-5 40-7 27-3 29-4 26-5l-5-2 6-1 7-1-3-5c-4-3-10-13-10-16 0-4 2-2 4 3 1 3 2 4 2 2 1-4 3-2 3 3 0 3 1 5 4 7l3 3v-3c0-2-1-3-3-3-3 0-3-1-1-3 3-3 0-9-3-8s-5-2-3-4c2-3 9 1 9 6l2 5 3 5a8 8 0 0 0 5 4c4 1 2 4-2 3h-4c0 2 5 3 9 2 4-2 9-10 16-24l6-14-1-10a92 92 0 0 1-2-29v-7a34 34 0 0 0-6 8c-6 10-14 20-15 19l3-5 4-5 1-4v-4l1-3v-3c0-1-2 0-3 2a33 33 0 0 1-7 6c-2 1-4 4-5 8l-2 6-6 12a9825 9825 0 0 1-6 18c0 2-2 2-4 2-2-1-2-2 1-7 4-7 13-29 13-32a59 59 0 0 1 12-14c18-18 25-30 26-45 0-4-3-7-7-5-1 0-2 0-2-2l-6-2c-3 0-7 0-10-2l-9-2c-5 0-9-5-10-12l-2-6a24 24 0 0 0-8-5c-3-1-3-3-1-3v-2c-1-1-2-3-1-4l-4-7a55 55 0 0 1-7-9l-2-3v4l-2 8c-2 4-7 7-7 5l2-2 2-3c-1-1 0-3 1-5 1-4 1-4-2-8a23 23 0 0 1-3-7c-1-3-4-6-8-7-6-1-5-3 1-3l6 2 4 5 1-5v-5l1 5 3 10c3 4 10 12 12 12v-14c-2-4-2-4 2-5 3-1 3-1 3 3v2l2 1c0 3 3 4 6 3l2 1-6 1c-5-1-6 0-7 2-1 4 3 9 6 9l3 1c0 2-2 2-6 0h-1l3 4 4 4 4 3h14c4 0 4 0-1-5a24 24 0 0 0-8-6c-6-1-7-4-1-3 5 2 14 9 14 12s11 1 14-1l6-4c3-1 4-2 4-4s1-2 3-2l4-4c1-5 4-8 4-5l-1 2c-1 0-2 2-1 4 0 3 0 3 6-3 3-3 5-6 5-8 0-5-1-5-4-2-2 2-2 1 1-5a77 77 0 0 0 4-18c1-8 1-10-1-10l-2-1c1-2-6-5-14-6a193 193 0 0 1-34-6c-1-2 2-1 16 1l17 2 11 3c6 2 7 2 5-2-1-2-3-3-8-3-8 0-9-2-2-3h5l-6-2a99 99 0 0 0-47-2c-10 2-19 7-15 8a177 177 0 0 0 36 7c3-1 4 0 4 1l3 3c3 1-3 1-19 1-25 1-32 0-33-3-1-1 0-2 2-1 5 2 20 4 27 3l7-1-11-3a49 49 0 0 0-26-3c-3 1-4 1-3-1l-1-2-2 2-3 4c-2 2-3 3-2 4 1 3 3 2 4-1s2-2 1 4v8c0 2-8 4-12 4s-10-4-10-6c0-1-1-2-4-2-4 1-5 1-4 3 2 4 2 8 0 8l-1-2-3-6c-6-5-15-3-10 2l2 8c0 6-1 5-2-1 0-5-2-8-6-7-3 1-4 1-3 5 1 3 0 3-1 3s-2-1-2-3v-2l-2 3-5 3-5 2c-3 4-3-2 0-7 4-8 4-17 0-21l-4-4-4-1-4-2-3-1 3 7 2 8c-2 3 1 6 5 6 3 0 3 1 2 2-1 2-2 2-5 1-4-2-5-2-6 1s0 6 3 6l3 1c0 2-7 2-7 0-1-2-5 7-5 10l3 1 3 1-3 1c-3 0-3 1-3 4s-1 4-2 4c-1 1-1 1 1 2h12c1 1 2 1 3-1 2-2 4-3 4-1l-4 6-5 5h4l7-2 4 1-4 2c-3 0-3 1-2 2 3 2 7 1 6 0 0-1 0-2 2-2 5 0 15-8 15-12l1-3 2 2v3c2 0 9-5 10-6 5-6 9 1 6 10l-3 5-6 4-4 4 4 1c2 1 9 2 16 1 11 0 14 1 17 3l5 4c0 2 2 4 5 5s4 3 3 3l-8-3-12-4-7-3 3-1 7 1 4 1-4-2c-4-2-10-2-12-1l-9 2-10 2c-1 0-3 0-5-2a8 8 0 0 0-7-3c-4 1-5 0-2-2 1-1 2-2 1-5l-1-3-5 2a52 52 0 0 1-14 3c-10 1-10 1-15-3a26 26 0 0 1-7-9c-3-9-1-24 4-30 2-3 2-5-1-5-5 0-3-5 2-9 7-3 7-7 3-12-4-3-4-3-1-6s16-5 19-2l6 5c3 2 4 4 4 7l2 6c2 2 2 2 12-1a828 828 0 0 1 12-3h5c3 1 6 0 15-4a96 96 0 0 1 13-6l6-5c2-2 6-6 9-7l4-3-4-2c-5-2-12-2-13 1l-3 1c-2 0-2-1-1-4l2-4 1-6c0-4-2-6-8-13-6-6-7-7-5-8 2 0 3 1 6 4a58 58 0 0 0 31 23c1-1-4-14-7-19-2-3-5-8-8-10l-3-5c1-1-7-11-9-11-1 0-2-1-2-3l-6-4c-5-1-6-1-9 1l-3 6c1 2 0 5-1 7s-1 3 1 4 3 5 1 5l-16-8 1-4c2-1 2-1 0-5-3-4-2-5 5-3 4 1 5 1 9-3 8-8 13-7 24 4 6 6 8 7 13 7l9 2 6 2 7 1 7 2c3 1 4 0 3-1l-2-2c-1 1-2 0-2-1 0-2-3-3-7-2s-5-3 0-7l4-4 6 4c7 3 11 3 9 0v-4c1-2 1-2 4 0 2 2 4 2 4 1s-2-3-4-3c-4-2-4-3-2-12 0-3 0-10-2-17a401 401 0 0 1-7-33c0-4 0-5 2-4s6-3 6-7c0-3 4-3 4 1 0 2-3 6-5 7-2 0 0 13 1 13l1-1c0-2 12-5 16-4l6-1c1-1 2-1 3 1s10 3 16 1c3-1 8-9 12-21 2-8 2-10-1-7l-9 1a43 43 0 0 0-28 9c-6 5-8 5-8 0 0-4-3-7-8-6-6 0-8 2-8 7l-1 3-2-4c0-5 4-9 9-9l8-1 7-3 12-5 9-4v-10c1-9 1-10 2-8 2 2 3 2 6 0 3-1 3-2 3-4v-6c1-2 1-4-1-8-3-6-7-9-7-5l-2 3c-2 1-2 5 0 11v3l-3-6c-1-5-3-6-5-6s-1-1 2-3c3-1 5-4 5-5l2-3 6-4 5-3-2 3c-2 2 3 7 5 5 3-2 3-4 0-6-2-2-3-4-1-4l5 5 3 5c0-3 4-4 7-2 4 5 6 1 2-3a10 10 0 0 1-3-5l-1-4 2-1c1 0 2 1 2 3-1 3 7-2 8-6 1-3 1-2 1 4l-1 7-1-3c0-2-1-2-4 0-2 2-2 2-1 4 3 1 2 4 0 10-2 4-3 5-5 4-8 0-15 6-12 10l1 11 1 9c3 0 8-4 8-6a37 37 0 0 1 13-16c4-2 10-6 13-11l2-5-6-1c-4 0-6 0-4-1a124 124 0 0 1 26-2c2 1-4 3-8 3-3 0-3 1-3 3 1 2 0 4-3 7-6 6-8 10-7 12 0 2 1 2 4 0l5-4c3-3 4-2 4 1l1 1a7 7 0 0 1 3-3l2-6 4-10 3-8c-1-2-1-3 1-1l4 1 1 1 1 2 1 2h-2c-3-2-8 3-9 8l-1 7c-1 1 0 2 2 2l3 1 2 1c5 0 8 9 5 16-2 5-12 15-15 15-5 0-16 18-17 28l-1 6c-3 5 12 40 19 45 4 3 5 6 3 6a94 94 0 0 1-11-5l-10-5 3 10a73 73 0 0 0 5 13l3 9 3 10c3 6 1 9-4 8h-4c0 1 2 2 5 2 6 0 8 1 6 3-1 2-1 2 1 3 3 2 7 11 6 13l-1 3-1 3-1 2h2l6 1c2 0 4 0 3 1 0 2 10 8 14 8l14 5c15 6 27 8 53 7 15 0 24 2 30 6l10 6c6 3 8 5 14 15l4 4c2 1 4 2 4 4a14 14 0 0 0 4 5l1 5c-1 3 4 11 8 13 8 4 15 10 16 13 3 5 13 7 42 9 17 1 15 0 24 18a63 63 0 0 0 7 11c1 0 21-20 23-24 2-3 2-4-3-15a4138 4138 0 0 1-10-22l-4-11-21 1a367 367 0 0 0-32 2c-9 2-14 1-12 0 2-2 37-5 49-5s14 0 13-3a161 161 0 0 0-19-34c-3-3-4-5-3-6 3-1 11 11 19 27l7 16h27a90 90 0 0 0-4-14c-11-29-20-64-15-59l1 4a484 484 0 0 0 24 74 346 346 0 0 0 17 45c2 1 8-6 9-11 1-3 2-4 3-2 2 1-3 10-7 15-3 4-3 4 0 9l3 6-1 1-3-6c-3-6-2-7-13 7l-7 8 4 10c5 10 7 13 7 10l1-3v6c0 4-2 7-7 12-4 3-6 6-5 7 2 1 1 3-3 3s-3-2 4-11l8-8-4-11a107 107 0 0 0-6-11s-4 2-7 6l-12 13a57 57 0 0 0-5 7c0 3 11 24 13 24l5 4 4 2-3 2c-3 2-3 3-2 6 2 5 2 7-1 2l-2-5-4 5c-4 5-5 6-1 6 3 0 12 4 14 6l5 2c2 0 3 3 1 4-1 1-1 2 1 2 5 0 10 3 8 4h-2c-3-2-7-2-10 1s-5 1-1-3c2-3 2-3-2-2a137 137 0 0 0-40 19c-1 0-2 1-1 3 2 6 2 7-1 8-5 1-6 0-6-4 1-3 2-4-17 10-8 6-13 8-10 4a141 141 0 0 1 21-16c3-1 5-3 5-4l-7-1c-6-1-8 0-11 3s-4 2-2-2c3-4 18-6 21-3s2 0-2-7a165 165 0 0 0-5-8l-19 17a154 154 0 0 1-29 23c-4 1-4-3 0-5 10-4 39-30 36-32-4-1-30 15-46 30l-8 7c-3 0 0-4 4-7 4-4 5-4 2-5-2-1-3-2-2-4s-3 0-10 8c-7 7-13 12-16 13-7 2-4 3 10 4s21 2 20 4l-2 1a35 35 0 0 0-4-1c-2-1-2 0 1 1 2 0 2 2 2 2-2 3-13 7-24 9-15 3-18 2-4-1 18-4 18-5 0-5-12 0-15 0-14 2 2 2 2 7 0 5h-36c-3 1-4 2-4 4 1 3 0 3-11 3l-22-1zm32-2-5-2a223 223 0 0 0-47-1l16 2c15 2 36 2 36 1zm-33-9c1-1 1-1 0 0h-9c-5-1-6-1-4-2s1-1-2-1h-4c0-2-4-2-5 0h-8c-8-2-39-4-39-3l28 7c11 1 42 1 43-1zm32 1-22-2c0 2 6 2 17 2h5zm39 0c0-2-11-4-16-4-1 0-2 0-3 2 0 1-3 2-8 2l10 1 17-1zm-146-5c-10-2-17-3-18-1s13 4 22 4c6 0 6 0-4-3zm124 2c1-2-8-2-12 0-2 1 0 1 5 1l7-1zm63-3-7-2a327 327 0 0 1-12-1h-4l4 2 4 1c1 1 14 2 15 0zm-284-6-5 1h3l2-1zm280 1h-4c-2 1-1 1 1 1l3-1zm-153-2h-3 3zm125-6h3c3 0 16-8 14-9-3-1-2-3 1-3 2 1 5-6 5-13l-4-19a108 108 0 0 1-6-25l-1-5-3 4c-4 4-10 7-10 5l2-2 6-4 5-5-2-14c-1-10-2-13 0-14 1 0 2-10 0-13-2-4-5 0-6 9-2 9-5 21-7 20a26 26 0 0 1 2-8l4-14 1-6h-6l-5 3c-1 2-3 1-3-1l10-5c8-2 8-2 3-2h-4l6-2c7 0 11-4 6-6-2 0-2-1 0-3 3-3 2-6-1-5l-3-1 3-1c2 0 3-1 3-2 0-3-1-3-4-2-5 1-5 1-5 5l-1 3-1-3-2-4h-1c2-1 4-6 4-8-1-1-2-2-7-1l-7 1 4-1 9-3 5-2h2l3-1c4 0 6-1 6-4l-1-4c-1 0-2-2-2-5v-4l-1 5-4 6-1-2c2-3-3-2-4 1-1 1-2 2-3 0-1-1-5 0-17 3a666 666 0 0 1-17 5l-1 5c-1 6 1 7 10 4l8-2-8 3-10 3-1 7-1 3v-7l-3-1c-2 0-2-1 1-2l1-2-5 2c-3 3-4 3-4 2s2-3 5-4c4-2 4-3 5-8 1-12 4-23 7-30 2-5 2-6 4-3s3 5 0 3c-1-1-2 0-4 6l-3 12c-1 5 0 5 3 5l30-7v-4c0-3-1-4-8-4h-15l3-2c3-1 3-2 1-2l-2-1c0-2 0-2 5 0l8 1c8-2 6-11-6-24l-14-16a26 26 0 0 0-6-6l1 2 1 2c-1 1-2 0-3-2-3-4-8-5-16-2-7 3-26 5-26 3 0-1 4-3 9-3 10-2 20-5 11-4-4 1-7 0-7-2l4-1c7 2 5-1-2-3l-14-5-25-6c-3 0-9-1-13-3-6-1-8-2-10 0v5l-1-2-3-1c-3 0-5-2-3-3 1-1 2 0 2 1h1l2-1v-1a6 6 0 0 0-2-3l-9-5c-7-4-11-4-11 0h3c4-1 5 1 1 3-3 2-8 0-8-3-1-4-10-8-19-8h-8c0 1 14 7 17 7l11 7 9 7c7 2 9 4 8 11l-1 6 4-3c3-2 3-2 2 0-2 2-1 5 1 5 1 0 3-5 3-8l3-2c4-1 4 0 1 4l-1 4 2 2c1 2 1 2 4-2l5-3-5 7-9 12a25 25 0 0 1-4 7v-3l2-5c-2-2-6 7-6 13-1 7-2 7-4 0-1-3-6 1-5 4l-1 2c-4-1-2-5 2-8 3-1 5-3 5-4l3-6 5-7c1-4 1-4-2-5-5-1-10-4-10-5l-5-6a34 34 0 0 1-6-9l-5-7c-4-3-5-3-11-2l-6-1c1-2-7-5-13-5-5 0-3 2 4 4 6 1 9 3 6 6-1 1-3 0-7-1l-7-2h-3c-2-2-7 0-7 2l-4 3-6 5v16c1 11 0 14-2 21a63 63 0 0 1-17 25c-5 5-7 7-5 7 2 1 9 24 9 30l1 3 1 4 2 4c2 1 2 2 1 3-1 4 8 28 12 33l4 5c-1 1 0 5 2 8l4 11 5 16 6 29c3 13 4 16 6 16l3 1 11 1c6 0 11 1 11 2 1 2 3 1 8-3l5-3 3-6c3-7 6-10 9-7s1 5-1 3c-3-2-4 0-7 8l-2 6-3 4-2 3 30-1h30v-4l1-5c1-1 0-2-1-2-1-1 0-1 1-1 2 0 2-2 3-6 1-10 3-17 5-17a42 42 0 0 0 2-13c2-11 1-13-1-14v-4c1-1 1-2-1-4s-2-4 0-4 2-1 1-8c0-6-1-8-3-10l-2-4c2-1 3-7 1-7l-1-1c1-1-1-2-4-3h-6c0 1-3 1-9-1-10-3-14-4-15-1a409 409 0 0 1-46 2c-3 0-5 0-6 2-2 2-4 3-3 1l-1-2c-2-1 0-10 3-10 1 0 2-1 2-3l2-3v-1c-1-2-1-4 2-10l2-7-1-2-2-7c-4-5-5-18-2-18v3c-1 7 6 21 10 18a78 78 0 0 0 11-22l-2-4c-2-2-3-6 0-6l3-2c1-2 1-2 4 0 2 3 1 5-2 5s-3 0 0 7c3 5 3 7 2 9-2 4-1 4 3 6l4 2c0 1 2 0 3-2a123 123 0 0 0 13-21l12-24c2-2 2-5 1-5a5 5 0 0 1-1-4h2c1 1 2 1 3-1 2-2 1-3-1-3v-1l3 1a54 54 0 0 0 15 8l1-2 1-3 1 3c0 4 0 4 7 7 6 2 7 2 8 0 1-1 1-1 1 2l2 5c1 1 1 2-1 2-2 1-4 4-7 13l-7 20-2 7-10 3-15 6-6 2 6 1c4 1 10 0 18-2 12-2 16-1 9 2-3 1-4 2-2 2l9-2c10-1 10 2 1 3-4 0-7 2-7 3-1 1 0 2 9 1h10l-2 2c-4 0-1 17 4 23l3 4c-2 1 0 5 6 11l5 8c0 1 2 4 5 6l4 6 7 15c7 15 9 24 9 39 0 9 0 9 4 10l8-1c3-1 5-1 8 1 6 3 4 5-1 3s-10-1-11 3c-2 4-5 3-4-2l-2-1-3 4c0 3 1 4 3 4 4 1 11 0 11-1zm-162-16c2-2 3-3 2-6l-3-3-2-2h2c2 0 2 0 2-4l-2-7a13 13 0 0 1-2-7l-4-11c-7-10-11-20-10-28v-6c-2-1-2-3 0-3 3 1 5 8 5 14a42 42 0 0 0 7 21c2 3 6 11 10 25l4 11c2 3 2 5 0 6l-6 1c-5 0-5 0-3-1zm-14-67-1 2 1 1v-3zm81 67 4-1c3 0 6-4 5-6l-7-4-5-3c0-5-10-4-12 1-1 3-4 3-4 0-1-4-9-4-12-1l-4 2 6-8a679 679 0 0 0 35-37c1 1-4 8-14 18-11 12-15 17-15 19s6 3 10 1c6-3 8-3 12 1 1 2 5 4 7 5l6 5c1 3 1 4-2 6-4 3-11 5-10 2zm-49-2-2-5-3-7c-1-3-2-4-2-1-1 3-4-9-5-17l-2-8-8-26a57 57 0 0 0-4-12l-1-3v-4c-2-3-1-3 0-3s3 2 3 4a868 868 0 0 0 13 45l2 10 4 9 3 5 4-6 5-5c1 0 5-3 9-8 11-11 15-16 13-15h-2c0-2 15-13 16-12s-8 12-28 32a313 313 0 0 0-16 18l2 4c1 2 2 5 1 6s-1 1-2-1zm139-58 5-7c5-6 5-4 0 4-3 4-5 6-5 3zm-15-42c-1-1 3-6 5-6l-1 2c-3 3-1 4 6 2h5c-1 1-14 3-15 2zm-172-7c-5-9-6-12-5-14 0-2 1-1 3 3l3 9c4 4 3-15 0-21a71 71 0 0 0-22-23c-8-5-6-7 2-2a65 65 0 0 1 23 26c2 7 2 17 0 22l-2 4zm158 0 4-2a48 48 0 0 0 7-3l4-2-3 2c-4 3-12 6-12 5zm37-7 2-1 1 1-1 1-2-1zm-205-16a36 36 0 0 0-12-5l-10-5c-1-3 2-10 4-11 2 0 2 0 0 4-3 5-2 7 6 9 8 1 13 4 15 8 2 3 0 3-3 0zm177-28 2-2v1c-1 2-2 3-2 1zm-167-2c-1-2-1-3 1-3 2 1 4-1 5-5 1-2 1-2 1 1l-2 5c-3 3-3 3-5 2zm27-9 2-5c1-1 0-3-2-5-2-1-4-3-3-4s3 1 7 5c3 3 3 3 5-4 1-4-2-13-5-18-4-6-5-6-5-1l-2 4-1-5c1-6 0-7-11-16-6-6-8-7-13-7s-9-1-9-2c0-2 18-1 19 1l11 6 1-2c2 0 2 1 2 5 0 3 2 5 5 9a40 40 0 0 1 11 19l-3 15-5 5c-4 5-5 6-4 0zm12 1 7-4 7-2-3 2c-5 3-11 5-11 4zm-43-19-1-4c1-2 1-2 2 1s1 5-1 3zm117-24c0-3 2-6 4-7 3-2 3-2 1 2-3 3-3 3 1 3 3 0 3 1 2 2h-8zm-20-4 7-8c1 0 3 0 4 2 2 2 2 2-1 2l-5 1c-2 1-2 2 0 3 1 0 1 1-2 1l-3-1zm-60-5-6-2-2-1c-1-1 8 1 11 3 5 2 3 2-3 0zm52 0c-5-1-6-2-7-5l1-2 1 2 6 3a30 30 0 0 1 7 3c2 1-1 1-8-1zm-34-14c-2-2 0-3 2-1v2l-2-1zM116 546l-3-1c-2 0-2 0 0 1 3 2 3 2 3 0zm36 1a94 94 0 0 0-25-3c-7 2-3 3 11 3h14zm232-2c0-2-1-3-3-3s-3-1-4-3l-2-2-3 2c-2 3-6 4-6 2s3-4 8-7c6-3 7-3 6 2-1 4 1 4 3 0 5-10 3-30-3-43l-3-8-3 5c-2 3-4 7-4 10l-2 14a31 31 0 0 0-1 10 45 45 0 0 1-6 19l-1-3 4-18 3-15-4-4-1-1c5 4 6 3 6-3 0-3-1-5-2-5l-1 2c2 3-1 2-4 0-2-2-3-2-4-1-2 1-2 2 0 2l1 1h-2c-2-2-4-1-9 1s-7 2-8 1c-3-2-7 2-7 7l-2 7c-1 2-3 6-3 10-1 6-1 6 1 6h2l3 5 3 4 2 2 4 1c2 1 23 4 39 5 2 0 3-1 3-2zm-40-14 2-7c2-7 2-9-1-13-3-3-3-4-1-4s6 6 6 10l-2 8c-2 3-2 6-2 7l-1 1-1-2zm-130 11h-7c-2 1-1 1 3 1l4-1zm22 0h-3c-1 1-1 1 1 1s3 0 2-1zm9 0h-3c-1 1-1 1 1 1l2-1zm84 0c0 2 1 2 4 0 1-1 1-2-2-5-3-4-8-6-6-2l-2 4c-2 3-2 3 0 3h6zm-143-2c12-2 26-2 24-1-1 1-1 2 2 2s3-1 3-3c-1-2 0-3 1-3l2-2c0-5-5-32-8-42a281 281 0 0 1-5-17l-3-7-1-2c0-2-5-8-6-6s1 6 2 5 1 0 1 2-7 9-8 7c-2-1-6 4-6 8-1 2-2 3-3 2-2 0-3 1-3 3l-4 7c-6 7-6 10-4 19s2 12 1 12l-2-6-2-8c-1-2-6 5-6 9l-2 2-3 4-2 5-5 5-3 4h5c11-2 21-3 21-1l-3 1-2 1c1 2 8 1 19 0zm-17-7 8-6a445 445 0 0 0 12-8c4-2 8-3 8-1l-6 4-13 7c-7 5-9 6-9 4zm18-1 18-13c3 0 0 3-8 9-9 6-15 8-10 4zm10 9a11 11 0 0 0-5 0l2 1 3-1zm39-2-2-1-3 1c0 1 1 2 3 2l2-2zm-12-1-2-1-1 1 2 1c1 0 2 0 1-1zm208-11c1-3 3-5 4-5l4-4c2-4 5-5 9-5l3-2c0-3 7-9 11-10 3 0 5-2 7-6l7-7 7-6c2-4 2-4 0-7l-2-4-16 17a183 183 0 0 1-17 16c0-2 5-8 19-21 10-11 13-14 12-17-1-4-4-4-10 1-7 6-8 7-8 4l2-2c3 0 1-3-3-3-9-2-8-2-10 3-1 5-1 5-6 5l-9 3-4 4c-1 0 0-3 2-5 2-3 4-4 11-5 3-1 4-2 4-4 0-4 3-6 8-5 8 2 13 2 15-2 2-3 2-4-3-13a478 478 0 0 0-6-10l-18 17-18 16 17-19 17-17-5-7c-6-8-7-9-4-9l5 6a38 38 0 0 0 5 7l5-7 4-5c1 1-1 5-3 9l-3 7 5 9 7 9 9-10 17-19 10-12c1-1-2-7-7-15-6-11-8-13-11-13h-9c0 2 6 5 10 4 3 0 4 0 3 1-1 3-7 3-14 0a29 29 0 0 0-7-3 297 297 0 0 0-27-5 97 97 0 0 1-17-4 12 12 0 0 0-5-2c-3 0-3-1-3-4 0-2-1-5-3-7l-2-3 1 5 1 18 1 14c1 1 1 2-1 2-2 1-3 2-3 7a47 47 0 0 1-3 17 502 502 0 0 0 5 67 41 41 0 0 1 3 9l3 13v18l4-4zm18-1c4-4 4-4 2-7-3-6-11-2-9 4l-1 4c-2 0-2 1-2 2 2 2 6 1 10-3zm64 1-1-2-1 1 1 1h1zm-48-13 15-9a33 33 0 0 0 9-4c0-2-6-10-8-10l-4 5c-3 4-3 4-2 0 1-5-3-3-4 2-1 4-2 5-5 5-5 1-13 6-13 9l4 7a77 77 0 0 0 8-5zm54 0 21-11a63 63 0 0 0 13-7c0-2-11-6-16-6h-5l3-4 2-6-7 3c-5 3-6 4-4 5 4 3 6 11 3 14-3 2-4 0-2-3 1-2 1-3-1-6-4-6-6-6-18 3l-7 5 4 7 7 10 7-4zm-26-23a32 32 0 0 0-6-9l-3 3c-1 2-1 3 4 8l5 9c0 2 1 2 3 0s1-3-3-11zm14 2 3-3c-2 0-10 5-10 6s2 1 7-3zm5-6c11-4 31-13 31-15l-3-5c-2-2-4-2-10-1-8 0-9 0-10-2-2-3-7-4-7-2s-3 2-4-1c-2-3-4-2-12 8l-8 9 3 7c5 9 5 9 9 7a47 47 0 0 1 11-5zm-147 0-3-1-1 1 2 2c2 0 2-1 2-2zm-21 0-1-2-2 1 2 1h1zm-175-4-1-1-1 1 1 2 1-2zm200 0-3-3c-2-1-2-1-1 1l4 2zm132-24h-6l-1 3v3l-2-3c-1-2-3-4-7-5h-7c0 1 0 3 2 5l2 4 3-3 3-3-1 3-2 5v4l2 4 7-8 7-9zm-326 13v-1l-2 2c0 2 1 1 2-1zm372-2c1-1 0-1-1-1l-2 1 1 1 2-1zm-206-1-4-4c-4-2-5-3-5-1l4 4c3 2 5 2 5 1zm-166-9c-1-5-2-4-2 1 0 2 1 3 2 3v-4zm361 1c1-1-6-17-8-17l-2 2h-2l1-4c2-1 1-7-1-6-2 0-15 18-15 20s1 2 5 1c4 0 5 0 8 3 2 3 3 3 8 2l6-1zm-204-5c-1-1-1-1-1 2 0 2 0 3 1 1v-3zm169-2c6-1 6-1 15-13l7-10-4-7-4-8-9 7-25 30a26 26 0 0 0 12 3l8-2zm-157 1-4-4-5-3 4 4 5 3zm11-1c1-1-5-7-6-7v3c1 4 5 7 6 4zm-194-5-2 2c0 2 0 2 1 1s2-2 1-3zm185 1a3 3 0 0 0-2-1v1h2zm-173-6-1 2c0 2 1 2 1 1v-3zm368-20a65 65 0 0 0 11-14l-10-24-9 9-13 13-4 5 4 7c2 4 3 6 4 4 0-3 4-3 4 0a12 12 0 0 1-1 5c-2 2 0 9 2 9l12-13zm-211 10-2-1-1 1 3 1v-1zm-21-1a9 9 0 0 0-4-2v2l4 1c2 0 2 0 0-1zm34-4a28 28 0 0 0-1-5h-11l5 2c3 1 4 2 3 4 0 2 2 4 4 4v-5zm-83 0c-2-2-4-3-6-2-2 0-3 1-3 2l9 4h3l-3-4zm13-2-2-1c-2 0-2 0 0 1 2 2 2 2 2 0zm11 0c1 0 1-1-1-2-4-2-7-2-8 1 0 1 3 3 6 2l3-1zm22 0-2-1c-1 1-1 1 1 1 1 0 2 0 1-1zm-18-3c-4-2-7-2-3 0l4 2c2 0 1-1-1-2zm11 1-4-2c-2 0-2 0 0 2l4 1h3l-3-1zm24 0a8 8 0 0 0-4-2c-2 0-1 1 0 2h4zm18-8c-1-1-3-2-7-1l-12 1-4 1 12 1c10 0 11 0 11-2zm-95-4 2-7c-1-1-2-1-3 3-4 8-3 11 1 3zm59 2c2-1 2-1 0-1l-4 1v2l4-2zm21-3c1-2 1-2-5-1-9 1-12 2-11 3 3 1 14 0 16-2zm-153 1-1-2-1 2v1l2-1zm114-2 7-2c2 0 3-1 3-2-2-2-5-1-12 2-5 3-6 4-4 4l6-2zm23-2h-2c-1 1-1 1 1 1 1 0 2 0 1-1zm-50-9c6-8 6-8 3-12-1-2-2-2-5 5-4 8-6 17-4 15l6-8zm9 4c5-3 6-6 3-6l-9 8c-3 4-1 3 6-2zm47 4h-3c-1 0-1 1 1 1l2-1zm255-20-6-15a586 586 0 0 1-14-33c-1-2-27-5-27-3a703 703 0 0 0 17 41c0 2 1 2 4 0 4-3 5 0 2 2l-3 3 3 7 5 13 3 6 8-10 8-11zm-294 15h-2l-2 2h2l2-2zm-103-4c-1-2-1-2-2-1v3c2 3 3 2 2-2zm79-2 2-4-3 3a12 12 0 0 0-3 6c0 3 3 0 4-4zm-99 3 1-9-1-6c-3 0-4-3-1-4 2 0 3-2 3-2 0-3-7-1-11 2-1 2-4 2-8 2s-6 1-6 2c0 2 6 11 10 14 5 3 12 4 13 1zm142-8c0-2-1-2-5 1a2298 2298 0 0 1-7 4l-3 3 8-2c6-3 8-5 8-6zm1 8 2-2-4 2-2 2 4-2zm117 0v-4c-1-4-6-5-6-2l-1 5c-1 3 0 3 3 2l4-1zm5-7c0-2-1-3-2-3l-1 2v4c0 3 0 3 1 2l2-5zm-286 3-3-4-2-3c1-1-3-6-4-6-2 0 1 10 3 12 3 3 7 4 6 1zm150-2 10-6 5-3 6-7 15-33a56 56 0 0 0-13-4c-1 0-22 37-22 40l2-1c4-3 6-4 7-2 0 0-4 5-10 9l-9 10c1 1 2 1 9-3zm41-6c-1-1-5 1-11 3-14 7-14 7 0 3 7-3 12-5 11-6zm-162 4v-4c-1-2-1-2-2 0l-1 4c0 3 2 2 3 0zm162-10c3 0 5-2 8-14 6-17 5-22-6-22h-4l-12 23-11 23 11-5a81 81 0 0 1 14-5zm-151 6-2-7c0-3-1-4-2-3-3 3-4 7-2 6s2 0 2 2c0 3 1 4 2 4 2 0 2-1 2-2zm-28-10c2-1 1-1-4-1h-11c-8-2-9 0-3 2a20 20 0 0 0 18-1zm268-7c1-10-9-34-13-34l-2-3c0-2-2-3-3-3l-6-4a28 28 0 0 0-9-6c-5-1-5-1-4 1l11 14c9 12 13 14 11 7-1-1 0-2 1-2s2 1 1 5l1 1c1-1 6 11 6 15 0 2 1 3 3 3h3l-3 1c-5 2-4 13 0 12 2-1 3-3 3-7zm30 6-4-2c-3 0-3 1-2 2h6zm-293-4h3l6-2 5-4c0-1 0-2-9 2-7 2-17 4-25 4l-3 1c2 2 19 2 23-1zm280-2-3-1-2 1 3 2c2 0 3-1 2-2zm11 0c-1-2-5-5-7-5l7 7v-2zm-38-2-2-1-2 1 2 1 2-1zm-354-6-2-2v2c1 3 3 3 2 0zm366-6-2-4 1 4 1 6v4l1-4-1-6zm-393 5h-2c-1 1-1 1 1 1 1 0 2 0 1-1zm33-4c0-2-3-2-4 1 0 1 0 2 2 2l2-2zm-47 0-2-3c-2-3-2-3 0 1 1 3 2 4 2 2zm395-5-1-4v6l2 4-1-6zm-385 0c1-1 0-2-3-1-5 1-6 2-4 4 1 2 2 2 4 0l3-3zm32 0-1 2v1c1-1 2-2 1-3zm14-1c2-5 1-6-3-3l-2 5c2 4 3 3 5-2zm-60-9c-1-1-1 0-1 2s0 2 1 1v-3zm311-4c-5-2-8-3-8-1l5 2c7 2 8 2 3-1zm93 0-3-4c-3-1-3 0 0 4s5 4 3 0zm-215-10c0-4 0-5-1-4l-2 13 3-9zm-5 2h-1l-2 3c0 2 1 2 2 0a8 8 0 0 0 1-3zm94-12c-1 0-3 3-3 5l2-1 1-4zm-194-3c3-3 3-6 0-7s-8 2-8 5c0 4 3 5 8 2zm306 1-3-2c-3-1-3 0-2 1 2 2 6 3 5 1zm-31-1c-2-3-7-3-8-1 0 1 1 2 5 2l3-1zm-300-3-2-2c-2 0-2 1-2 2l2 1 2-1zm320-2c-4-3-11-7-16-7-7-1-5 0 7 5 11 5 14 5 9 2zm-115-5-3-3h-2l2 3c0 3 3 2 3 0zm84-1h3c0-1-7-2-15-2h-13l9 3c7 2 9 2 10 0l6-1zm-319-1-1 1 1 2v-3zm70-9c2-2 0-3-2 0-3 1-3 2-1 2s3-1 3-2zm-78-1a8 8 0 0 0-4-1l1 1h3zm174-1c1-1 0-2-3-2h-4c0 4 4 5 7 2zm-25-7c-2-2-4-1-3 1l3 1c2-1 2-1 0-2zm-46-1-4 1h2c3 0 3-1 2-1zm-7-2c1-2-1-1-4 1s-3 2 0 1l4-2zm43 1-3-1-3 1c1 2 6 1 6 0zm29 0c0-1-1-2-3-2-4-1-5 2-1 3s4 1 4-1zm-40-1h-7l5 2c3 0 4-1 2-2zm26-1-2-1v1l1 1 1-1zm46 0c-4-2-5-2-5 0l4 1c3 0 3 0 1-1zm-94-1v-2l-4 2c-2 1-2 1 0 1l4-1zm41 0-5-3-6-4c-1-3-6-4-16-3-6 1-13 3-13 5a77 77 0 0 0 25-1l13 7 2-1zm34-5 10-2c5 0 7-2 4-5-4-2-1-5 8-5 9-1 16-3 16-5l-2-7c-1-5-2-6-4-5-2 0-2 1-5-10-1-4-2-10-4-13l-3-7a174 174 0 0 0-6-12 57 57 0 0 1-5-11l-3-4a124 124 0 0 0-36-11l-8-2c-2-1-3 0-2 1l2 26c0 31 0 34 5 44 5 13 4 23-2 12l-5-13c-2-6-3-7-4-5s-2 3-4 3h-2c-1 1 5 9 13 18l6 6c0 3 7 7 16 8l9 1 6-2zm-72-9v-1c-2 0-6 3-6 4 0 2 5-1 6-3zm-3-2c6-3 18-4 24-1 4 2 6 2 4-1l-3-1-5-3a37 37 0 0 0-11-5l-11-4a5 5 0 0 0-3-1c-2 0-2 1-1 4v9l1 5 5-2zm122-7c-1-4-1-4-4-3l-2 4c0 2 0 3 3 3 3-1 3-1 2-4zm-102-17-1-1v2c1 2 2 1 1-1zm87-9-1 2c0 2 1 2 1 1v-3zm6-7c-1-4-4-6-4-3l5 9-1-5zm-84 3-1-1-2 2 2 1 1-2zm-91-1-2-2c-3-1-4-1-2 2 2 2 4 2 4 0zm151-31h-1v2l2 1-1-3zm9-8c-3-3-3-1-1 4 1 3 2 3 2 2 1-2 0-4-1-6zm12-4-2-3 4 10c1-1 0-3-2-7zm-21 2c0-2-1-2-3-2l-2 3 2 1c2 1 3 0 3-2zm-5-5-3-2c-3 0-3 0-1 1 2 2 4 2 4 1zm-23-4h-3c-1 0-1 1 1 1l2-1zm39-16-2 2-2 5 2-2 2-5zm-17 3 1-13c1-10 2-11 6-15l4-6-5 1c-3 2-5 4-8 11-4 9-6 20-5 23 1 2 6 1 7-1zm7-22-1-1-1 1v1l2-1zm41-32 2-5-3 4c-3 3-3 5-1 5l2-4zm-31 2c3-1 3-6 1-6-3 0-5 3-5 5s1 2 4 1zm-8-3-1-2-1 2v1l2-1zm-22-9c0-4 0-5-1-3-1 1 0 9 1 9v-6zm65-4c-1-2-4 0-3 2h3v-2zm-66-10h-1v2-2zm-3-8-3-2 4 6-1-4zm16 0c0-3 0-4-1-2l2 6-1-5zm168 492h9c2 1 0 1-5 1-4 0-6 0-4-1zm196-13c0-1 4-2 5 0l-2 1-3-1zm-9-1h2-2zm-122-2 6-2c3-1 4-1 2-2a9 9 0 0 0-5-1c-9 2-16 2-16 1l2-2 56-2a668 668 0 0 0 54-1l12-1 11 1v-6l-1-6-5 1c-5 0-6-1-1-3h6c3 1 4 3 4 7v6h7l26 3-40 1c-38 0-50 1-32 3 12 1 26 3 25 4l-15-2a386 386 0 0 0-96 1zm81-15h5c0 1-2 2-4 1-3 1-3 0-1-1zm-436-6c-4-3-6-7-3-9 3-1 7-1 7 1a2 2 0 0 1-2 2c-4 0-3 2 2 5 5 4 2 4-4 1zm5-4 1-2 2 2-1 1-2-1zm-8-9c0-1 4-2 5-1l1-3c0-2 1-3 3-3l3 1-1 1-2 3c0 3 0 3-4 3l-5-1zm36-8 2-2c2-2 2-2 1 0l-3 2zm451-25 2-3 4-6c1-3 2-4 3-3 1 3-3 10-7 12h-2zm10-15h3-3zm-17-6c3-6 5-8 6-8l1 1-6 8-1-1zm-465-78c-14-2-18-4-14-6 1-1 2-1 3 1 3 3 13 4 15 1 1-1 1-1 1 1 0 1 1 2 3 2 4 0 8 2 8 3 0 2-1 1-16-2zm-30-35 1-7c1-4 0-5-3-8-4-4-4-4-2-4 4 0 7 3 8 9a19 19 0 0 1-1 9c-2 4-5 4-3 1zm71-15 1-4c1-2 1-1 1 2-1 5-2 6-2 2zm-35-11c-3 0-3-4 1-6 3-2 3-2 3 0l-3 2v2h5l5 1c0 1-7 2-11 1zm51-11-9-4c0-1 1-1 11 1 16 5 14 6-2 3zm152-40c0-3 81-7 129-5l37 2c12 0 13 0 13 3a499 499 0 0 0-39-1 804 804 0 0 0-132 2c-6 1-8 1-8-1zm-39-44c3-2 23-3 23-1l-6 2h-13c-6 1-7 1-4-1zm-1-25c1-2 5-3 11-4 6 0 4 2-1 3a42 42 0 0 0-8 2c-2 1-2 1-2-1zm0-33 6-1c4 0 5 0 2 1-5 2-8 2-8 0zm1-102c-2-2-1-6 1-7 2 0 2-6-1-9v-3c1 0 3 2 4 5s3 5 4 5c2 0 2-1 0-5-2-1-2-3-1-3 3 0 1-3-5-8a26 26 0 0 0-7-4c-1 1 3 18 4 18l1 1-4 2c-3 0-4 0-3-2s0-3-2-3l-4-2-3-2c-2 0-6-9-5-13 1-2 0-3-1-4-3-1-2-2 1-2s3 1 4 6c0 4 1 7 2 7s1-2 1-5l1-5 1 3 3 11 2 2v-4l-1-8c0-4-3-7-9-10l-5-3-2-1c-2 0-6-4-6-6s4-1 7 1c2 2 3 2 4 0a31 31 0 0 1 8-6c9-6 19-14 17-16-2-4 14 5 21 12 6 5 4 8-2 3-6-4-7-4-8 1-1 10-3 16-5 17-1 1 0 7 2 7l3-6c1-3 3-7 5-8l4-5 3-1c2 1 2 2-1 5l-8 13-4 9 3 3c3 3 3 5 0 7l-2 2c1 3 0 4-4 4l-5 1-2 2c-2 0-3 1-3 2 1 2-2 3-3 2zm-72-8c0-2 6-5 8-5 3 0 2 3-1 3l-4 2h-3zm36-5c5-4 6-5 6-2l-5 4-5 3zm-8-5c-2-2-1-3 3-1 3 2 3 2 0 2l-3-1zm-2-7s2-2 5-2c2-1 6-3 7-5 3-3 5-4 5-2s-17 12-17 9z"></path></svg>
			</div>
			<div class="title">
				<a href="https://ian.wold.guru/" class="h-card" rel="me">Ian Wold</a>
			</div>
			<ul>
				<li><a  href="../about.html">About</a></li>
				<li><a  href="../now.html">Now</a></li>
				<li><a  href="../connect.html">Connect</a></li>
				<li><a href="https://buttondown.email/ianwold" target="_blank">Book Club</a></li>
			</ul>
		</nav>
		
		




<header class="content">
	<h1>An Introduction to Sprache</h1>
	<small>
		<span class="date">
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg> 22 January 2016
		</span>
		<span class="time">
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> 28  Minutes 
		</span>
		<span class="history">
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-git-commit"><circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line></svg> <a href="https://github.com/IanWold/ianwold.github.io/commits/master/Site/Posts/sprache.md">History</a>
		</span>
	</small>
	<p>Sprache is a parser-combinator library for C# that uses Linq to construct parsers. In this post I describe the fundamentals of understanding grammars and parsing them with Sprache, with several real-world examples.</p>
</header>

<div class="content hero">
	<img src="https://images.unsplash.com/photo-1494435658045-a657e4a01bcc?w=1000&h=525&fit=crop&crop=entropy" />
</div>

<div class="content">
	
		<div class="pane">
			<ul>
				
				<li>
					<a href="#prerequisites">
						
							<b>Prerequisites</b>
						
					</a>
				</li>
				
				<li>
					<a href="#linq">
						
							LINQ
						
					</a>
				</li>
				
				<li>
					<a href="#backus-naur-form">
						
							Backus-Naur Form
						
					</a>
				</li>
				
				<li>
					<a href="#sprache">
						
							<b>Sprache</b>
						
					</a>
				</li>
				
				<li>
					<a href="#our-first-language">
						
							Our First Language
						
					</a>
				</li>
				
				<li>
					<a href="#comma-separated-values">
						
							Comma-Separated Values
						
					</a>
				</li>
				
				<li>
					<a href="#xml">
						
							XML
						
					</a>
				</li>
				
				<li>
					<a href="#json">
						
							JSON
						
					</a>
				</li>
				
				<li>
					<a href="#my-work-with-sprache">
						
							<b>My Work With Sprache</b>
						
					</a>
				</li>
				
				<li>
					<a href="#further-reading">
						
							Further Reading
						
					</a>
				</li>
				
			</ul>
		</div>
	

	<div class="post">
		
			<div class="series">
				<p style="font-weight: bold;">This is a post in my <a href="../Series/past_articles.html">Past Articles Series</a>.</p>
				<p>Several years before I started blogging at ian.wold.guru, I maintained a site with a CV and a small number of articles. I've preserved those articles on this site in this series.</p>
			</div>
		

		<p>As my activity on this blog and my GitHub account may attest, I'm quite fond of a C# library called Sprache. Sprache is a parser-combinator that uses LINQ (Language INtegrated Query) to allow for the elegant construction of parsers in C#. I've been using Sprache for three years now, before I started college, and I've used it to implement a number of domain-specific languages (DSLs) both in side projects on my GitHub and on applications I've worked on. It's only natural I would want to share my favorite C# library with my fellow undergraduate classmates, but there are several factors which make it rather unapproachable for the average undergraduate computer science student. Thus, I have written this piece to provide a completely introductory tutorial to using Sprache.</p>
<p>I'll explain LINQ and BNF, and then I'll walk you through the implementation of a few simple grammars in Sprache such that I may touch upon all the most important concepts in the Sprache library to allow the reader to immediately begin to implement the grammars which they desire. At the end of this post, I link to several articles which cover the framework and other related readings. In the future, I may also write a short handbook/reference to certain Sprache concepts.</p>
<p>One does not necessarily need to have an understanding of C# to begin using Sprache, but a familiarity of a similar language (i.e. Java) would go a long way. I'm going to assume the reader has an understanding of object-oriented programming. I won't be going into an explanation of what a parser-combinator is, nor what a &quot;combinator&quot; is, in general. If you would like to become more involved in the development of Sprache, though, you should definitely familiarize yourself with the concept. I provide some links at the end of this tutorial to that end.</p>
<section id="prerequisites">
<h1>Prerequisites <a class="section-link" href="https://ian.wold.guru/Posts/sprache.html#prerequisites">#</a></h1>
<p>To begin with, of course, you'll need to download Sprache. You can find it <a href="https://github.com/sprache/Sprache">on GitHub</a>.</p>
<section id="linq">
<h2>LINQ <a class="section-link" href="https://ian.wold.guru/Posts/sprache.html#linq">#</a></h2>
<p>LINQ, short for Language INtegrated Query, is a wonderful feature of Visual C# which adds data-querying operators to C#. LINQ expressions are sometimes (grammatically incorrectly) referred to as &quot;LINQ queries&quot; as they read rather fluently as a query on a data set. Here is an example of a LINQ expression:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F92672;">var</span><span style="color: #F8F8F2;"> myList </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">List</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt;()</span></div><div class='line'><span style="color: #F8F8F2;">{</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #E6DB74;">&quot;hello&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #E6DB74;">&quot;world&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #E6DB74;">&quot;how&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #E6DB74;">&quot;are&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #E6DB74;">&quot;you&quot;</span></div><div class='line'><span style="color: #F8F8F2;">};</span></div><div class='line'><span style="color: #F92672;">var</span><span style="color: #F8F8F2;"> startsWithH </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> s </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> myList</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">where</span><span style="color: #F8F8F2;"> s.</span><span style="color: #A6E22E;">ToCharArray</span><span style="color: #F8F8F2;">()[</span><span style="color: #AE81FF;">0</span><span style="color: #F8F8F2;">] </span><span style="color: #F92672;">==</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;h&#39;</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> s;</span></div><div class='line'><span style="color: #F92672;">foreach</span><span style="color: #F8F8F2;"> (</span><span style="color: #F92672;">var</span><span style="color: #F8F8F2;"> a </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> startsWithH)</span></div><div class='line'><span style="color: #F8F8F2;">	Console.</span><span style="color: #A6E22E;">WriteLine</span><span style="color: #F8F8F2;">(a);</span></div><textarea data-torchlight-original="true" style="display: none !important;">var myList = new List&lt;string&gt;()
{
    "hello",
    "world",
    "how",
    "are",
    "you"
};
var startsWithH =
    from s in myList
    where s.ToCharArray()[0] == 'h'
    select s;
foreach (var a in startsWithH)
	Console.WriteLine(a);
</textarea></code></pre>
<p>Here, we start with a list of words, and we desire to print to the console each word which begins with the letter 'h'. The variable <em>startsWithH</em> is defined with the following LINQ expression, which is how we sort out those words which start with 'h':</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> s </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> myList</span></div><div class='line'><span style="color: #F92672;">where</span><span style="color: #F8F8F2;"> s.</span><span style="color: #A6E22E;">ToLower</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">ToCharArray</span><span style="color: #F8F8F2;">()[</span><span style="color: #AE81FF;">0</span><span style="color: #F8F8F2;">] </span><span style="color: #F92672;">==</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;h&#39;</span></div><div class='line'><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> s;</span></div><textarea data-torchlight-original="true" style="display: none !important;">from s in myList
where s.ToLower().ToCharArray()[0] == 'h'
select s;
</textarea></code></pre>
<p>Let's look at what's going on here. First, we have a <em>from</em> statement. This will iterate over each object in <em>myList</em>, using <em>s</em> as the iterator variable. Next, we have a <em>where</em> statement, which filters out the objects in <em>myList</em> based on the condition provided. Note that several <em>where</em> statements could be specified here. At the end of this LINQ expression, as with every LINQ expression, we have a <em>select</em> statement, which returns each &quot;queried&quot; object. In this case, we only desire to return the strings which begin with the letter 'h'.</p>
<p>LINQ supports several operators apart from <em>from</em>, <em>where</em>, and <em>select</em>, though these are the main ones. Microsoft, naturally, provides a very in-depth <a href="https://msdn.microsoft.com/en-us/library/bb394939.aspx">list of LINQ operators</a>, though Wikipedia has <a href="https://en.wikipedia.org/wiki/Language_Integrated_Query#Standard_Query_Operators">a much more succinct list</a>.</p>
<p>Sprache uses LINQ to construct its parsers. This allows for quick implementation and easy and intuitive readability.</p>
</section>
<section id="backus-naur-form">
<h2>Backus-Naur Form <a class="section-link" href="https://ian.wold.guru/Posts/sprache.html#backus-naur-form">#</a></h2>
<p>Backus-Naur Form, or BNF for short, is a metalanguage used to describe the grammars and syntax of context-free grammars (essentially, for our purposes, this means the grammars of computing languages). BNF defines expressions in terms of other expressions and strings using a number of rules which will become more familiar as we begin implementing these grammars in Sprache.</p>
<p>As an example, suppose I want to define a grammar which specifies an arithmetic expression which might add, subtract, multiply, or divide two digits. I'll provide a BNF definition of this grammar, and then explain it.</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-bnf"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">&lt;expr&gt;      ::= &lt;add&gt; | &lt;subtract&gt; | &lt;multiply&gt; | &lt;divide&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;add&gt;       ::= &lt;digit&gt; &quot;+&quot; &lt;digit&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;subtract&gt;  ::= &lt;digit&gt; &quot;-&quot; &lt;digit&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;multiply&gt;  ::= &lt;digit&gt; &quot;*&quot; &lt;digit&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;divide&gt;    ::= &lt;digit&gt; &quot;/&quot; &lt;digit&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;digit&gt;     ::= &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;</span></div><textarea data-torchlight-original="true" style="display: none !important;">&lt;expr&gt;      ::= &lt;add&gt; | &lt;subtract&gt; | &lt;multiply&gt; | &lt;divide&gt;
&lt;add&gt;       ::= &lt;digit&gt; "+" &lt;digit&gt;
&lt;subtract&gt;  ::= &lt;digit&gt; "-" &lt;digit&gt;
&lt;multiply&gt;  ::= &lt;digit&gt; "*" &lt;digit&gt;
&lt;divide&gt;    ::= &lt;digit&gt; "/" &lt;digit&gt;
&lt;digit&gt;     ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
</textarea></code></pre>
<p>Let's look at each of the elements and what they do. First, the most notable and important element is the reference for an expression, which looks like the following:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-bnf"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">&lt;expression_name&gt;</span></div><textarea data-torchlight-original="true" style="display: none !important;">&lt;expression_name&gt;
</textarea></code></pre>
<p>The expressions are referenced by this convention, and they are defined with the <em>::=</em> operator. In defining such expressions, a number of rules can be used. Look at the definition for <em>expr</em>:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-bnf"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">&lt;expr&gt;      ::= &lt;add&gt; | &lt;subtract&gt; | &lt;multiply&gt; | &lt;divide&gt;</span></div><textarea data-torchlight-original="true" style="display: none !important;">&lt;expr&gt;      ::= &lt;add&gt; | &lt;subtract&gt; | &lt;multiply&gt; | &lt;divide&gt;
</textarea></code></pre>
<p>The bar ('|') denotes an <em>or</em> relationship. That is, an expression <em>expr</em> can be either an <em>add</em>, <em>subtract</em>, <em>multiply</em>, or <em>divide</em> expression.</p>
<p>Now let's look at the definition of the <em>add</em> expression:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-bnf"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">&lt;add&gt;       ::= &lt;digit&gt; &quot;+&quot; &lt;digit&gt;</span></div><textarea data-torchlight-original="true" style="display: none !important;">&lt;add&gt;       ::= &lt;digit&gt; "+" &lt;digit&gt;
</textarea></code></pre>
<p>This specifies that an <em>add</em> can be a <em>digit</em>, followed by a plus sign, followed by another <em>digit</em>.</p>
<p>You might notice a bit of an inefficiency in the grammar I defined above. Namely, we define <em>add</em>, <em>subtract</em>, <em>multiply</em>, and <em>divide</em> separately, but due to the similarity in their structures, it feels like we should be able to define them all together. While there are certainly good reasons one might want to define them separately as I did above, for succinctness one might desire to redefine the grammar as such:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-bnf"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">&lt;expr&gt;      ::= &lt;digit&gt; (&quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot;) &lt;digit&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;digit&gt;     ::= &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;</span></div><textarea data-torchlight-original="true" style="display: none !important;">&lt;expr&gt;      ::= &lt;digit&gt; ("+" | "-" | "*" | "/") &lt;digit&gt;
&lt;digit&gt;     ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
</textarea></code></pre>
<p>Here I introduce a grouping of terms, defined by the parentheses. Now, <em>expr</em> is defined to be two <em>digits</em> separated by either an addition, subtraction, multiplication, or division symbol. This is, however, a rather dumb grammar, in that only two <em>digits</em> can be used in the arithmetic expression, while we might want to allow any number to be used. We can extend the grammar further to allow for this:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-bnf"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">&lt;expr&gt;      ::= &lt;number&gt; (&quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot;) &lt;number&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;number&gt;    ::= &lt;integer&gt; [&quot;.&quot; &lt;integer&gt;]</span></div><div class='line'><span style="color: #F8F8F2;">&lt;integer&gt;   ::= +(&quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;)</span></div><textarea data-torchlight-original="true" style="display: none !important;">&lt;expr&gt;      ::= &lt;number&gt; ("+" | "-" | "*" | "/") &lt;number&gt;
&lt;number&gt;    ::= &lt;integer&gt; ["." &lt;integer&gt;]
&lt;integer&gt;   ::= +("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")
</textarea></code></pre>
<p>Here we have broken a number into two parts, a <em>number</em> and an <em>integer</em>. Where I define <em>integer</em>, I introduce a plus sign, which allows the expression which it suffixes to be repeated one or more times. Where I define <em>number</em>, I introduce the square brackets, which surround optional expressions. Thus, the following terms are captured by the expression <em>number</em>: 0, 125, 3.14, and 123.456. However, the following terms are not captured by <em>number</em>, and I will allow the reader to postulate why they are not, and how the grammar might need to be altered to capture them: .31, -12, -12.56, and -.987.</p>
<p>When we want to parse a language with Sprache (or any other parser, for that matter), we will first define the language in BNF, so that we can easily reference the pieces of the parser we must create, and to keep track of our progress.</p>
</section>
</section>
<section id="sprache">
<h1>Sprache <a class="section-link" href="https://ian.wold.guru/Posts/sprache.html#sprache">#</a></h1>
<p>Ultimately, once you get used to using LINQ to construct parsers, Sprache is just another library, and becoming proficient in Sprache is the same process one should be used to of learning the methods given by the library and learning how to ask questions on stack overflow.</p>
<p>Let's begin familiarizing ourselves by constructing a parser which can parse the string &quot;hello&quot; into a string &quot;hello.&quot; This is an entirely non-useful task for Sprache, but it gets our feet wet:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt; myParser </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> str </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">String</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;hello&quot;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> str;</span></div><div class='line'><span style="color: #F92672;">string</span><span style="color: #F8F8F2;"> val </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> myParser.</span><span style="color: #A6E22E;">Parse</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;hello&quot;</span><span style="color: #F8F8F2;">);</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;string&gt; myParser =
    from str in Parse.String("hello").Text()
    select str;
string val = myParser.Parse("hello");
</textarea></code></pre>
<p><em>val</em> will, unremarkably, be &quot;hello.&quot;However, the parser should be very easy to understand, especially given our understanding of the working of a LINQ expression. The method <em>String(string)</em> is a parser which parses any string you desire (in this case, we desired to parse the string &quot;hello&quot;). The <em>String</em> parser returns an enumerable of chars, so we need to use <em>Text</em> to turn the enumerable into a string. From there, it should be rather obvious what is going on.</p>
<p>Now, let's suppose we want to parse the string &quot;hello&quot; multiple times, separated by whitespace, and we want to know how many times &quot;hello&quot; appears. We can extend our parser above like so:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">int</span><span style="color: #F8F8F2;">&gt; myParser </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> str </span><span style="color: #F92672;">in</span></div><div class='line'><span style="color: #F8F8F2;">        Parse.</span><span style="color: #A6E22E;">String</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;hello&quot;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.WhiteSpace.</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">())</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> str.</span><span style="color: #A6E22E;">Count</span><span style="color: #F8F8F2;">();</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;int&gt; myParser =
    from str in
        Parse.String("hello").Text()
        .DelimitedBy(Parse.WhiteSpace.Many())
    select str.Count();
</textarea></code></pre>
<p>Testing this parser with the string &quot;hello   hellohello  hello&quot; should return a result of 4. Because of the way our parser is constructed, it is relatively straightforward to read it as &quot;parse the string &quot;hello&quot; delimited by whitespace.&quot; But let's look at what's going on here. <em>DelimitedBy</em> will attempt to match the &quot;hello&quot; parser, and then it will look for whitespace (<em>WhiteSpace().Many()</em> is a parser itself which matches 0 or more different whitespace characters in a row), and will then look to match &quot;hello&quot; again and more whitespace, until the parser is no longer able to match either &quot;hello&quot; or whitespace, at which point it returns an <em>IEnumberable</em> containing several &quot;hello&quot;s. Our <em>select</em> statement can then select the <em>Count</em> of that <em>IEnumerable</em>, and thus we can obtain the number of times &quot;hello&quot; is parsed.</p>
<p>This idea of chaining parsers onto each other, as <em>DelimitedBy</em> is chained onto <em>String</em>, is the entire concept behind parser-combinators.</p>
<p>A slightly more complicated task might be to try to parse a variable name surrounded by whitespace (often called an &quot;identifier&quot;). This example is given on the Sprache GitHub page:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt; identifier </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> leading </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.WhiteSpace.</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> first </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.Letter.</span><span style="color: #A6E22E;">Once</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> rest </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.LetterOrDigit.</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> trailing </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.WhiteSpace.</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">(first.</span><span style="color: #A6E22E;">Concat</span><span style="color: #F8F8F2;">(rest).</span><span style="color: #A6E22E;">ToArray</span><span style="color: #F8F8F2;">());</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;string&gt; identifier =
    from leading in Parse.WhiteSpace.Many()
    from first in Parse.Letter.Once()
    from rest in Parse.LetterOrDigit.Many()
    from trailing in Parse.WhiteSpace.Many()
    select new string(first.Concat(rest).ToArray());
</textarea></code></pre>
<p>Thus, &quot;   abc123   &quot; should come out as &quot;abc123&quot;. Notice how staggering several <em>from</em> statements in a row reads as though we are saying &quot;then&quot;. For example, this parser could be read by a human as &quot;Parse many whitespace characters, <em>then</em> parse one letter, <em>then</em> parse 0 or more letters or digits, <em>then</em> parse more whitespace, and return the first letter and the rest of the letters/digits concatenated to it&quot;.</p>
<section id="our-first-language">
<h2>Our First Language <a class="section-link" href="https://ian.wold.guru/Posts/sprache.html#our-first-language">#</a></h2>
<p>So, let's now define the grammar for a small DSL, and we'll try to parse it. Let's make a language that defines variables: we can have an identifier, followed by a colon, and then a string, and we can define as many variables as we want on different lines. Ultimately, we want to parse this into a dictionary. So, our resulting language could look like this:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">identifier1 : &quot;hello&quot;</span></div><div class='line'><span style="color: #F8F8F2;">identifier2 : &quot;world&quot;</span></div><div class='line'><span style="color: #F8F8F2;">identifier3 : &quot;yay parsing&quot;</span></div><textarea data-torchlight-original="true" style="display: none !important;">identifier1 : "hello"
identifier2 : "world"
identifier3 : "yay parsing"
</textarea></code></pre>
<p>The BNF for the language looks like this:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-BNF"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">&lt;block&gt;        ::= &lt;expr&gt; *(&lt;newline&gt; &lt;expr&gt;)</span></div><div class='line'><span style="color: #F8F8F2;">&lt;expr&gt;         ::= &lt;identifier&gt; [&lt;whitespace&gt;] &quot;:&quot; [&lt;whitespace&gt;] &lt;string&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;identifier&gt;   ::= &lt;letter&gt; *(&lt;letter&gt; | &lt;digit&gt;)</span></div><div class='line'><span style="color: #F8F8F2;">&lt;string&gt;       ::= &quot;\&quot;&quot; *(&lt;any_character&gt;) &quot;\&quot;&quot;</span></div><textarea data-torchlight-original="true" style="display: none !important;">&lt;block&gt;        ::= &lt;expr&gt; *(&lt;newline&gt; &lt;expr&gt;)
&lt;expr&gt;         ::= &lt;identifier&gt; [&lt;whitespace&gt;] ":" [&lt;whitespace&gt;] &lt;string&gt;
&lt;identifier&gt;   ::= &lt;letter&gt; *(&lt;letter&gt; | &lt;digit&gt;)
&lt;string&gt;       ::= "\"" *(&lt;any_character&gt;) "\""
</textarea></code></pre>
<p>I'll imagine you can determine what <em>newline</em>, <em>letter</em>, <em>digit</em>, and <em>any_character</em> are. Note, though, that we technically want <em>any_character</em> to parse any character except a quotation mark.</p>
<p>Sprache already contains parsers for a letter, digit, and any character, so we should be all good to go from here. We already have our identifier parser, so let's add to that by constructing our string parser:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt; identifier </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> first </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.Letter.</span><span style="color: #A6E22E;">Once</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> rest </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.LetterOrDigit.</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">(first.</span><span style="color: #A6E22E;">Concat</span><span style="color: #F8F8F2;">(rest).</span><span style="color: #A6E22E;">ToArray</span><span style="color: #F8F8F2;">());</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt; stringParser </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> first </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;&quot;&#39;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> text </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.AnyChar.</span><span style="color: #A6E22E;">Except</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;&quot;&#39;</span><span style="color: #F8F8F2;">)).</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> last </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;&quot;&#39;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> text;</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;string&gt; identifier =
    from first in Parse.Letter.Once()
    from rest in Parse.LetterOrDigit.Many()
    select new string(first.Concat(rest).ToArray());
Parser&lt;string&gt; stringParser =
    from first in Parse.Char('"')
    from text in Parse.AnyChar.Except(Parse.Char('"')).Many().Text()
    from last in Parse.Char('"')
    select text;
</textarea></code></pre>
<p>Here we use <em>Except</em> to add an exception to the <em>AnyChar</em> parser. In addition, we use <em>Text</em> at the end to tell sprache to convert the IEnumerable returned by <em>Many</em> into a string. Now, we can add the parser for the expressions:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #88846F;">//Adding to the code above:</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">Dictionary</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">, </span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt;&gt; expr </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> id </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> identifier</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> colon </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;:&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> str </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> stringParser</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">Dictionary</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">, </span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt;() { { id, str } };</span></div><textarea data-torchlight-original="true" style="display: none !important;">//Adding to the code above:
Parser&lt;Dictionary&lt;string, string&gt;&gt; expr =
    from id in identifier
    from colon in Parse.Char(':').Token()
    from str in stringParser
    select new Dictionary&lt;string, string&gt;() { { id, str } };
</textarea></code></pre>
<p><em>Optional</em> is used here - that does exactly what it says - it makes the parser optional. In addition, I introduced <em>Token</em>, which will parse whitespace before and after the <em>CHar</em> parser. Notice how we are able to reference the parsers we created earlier, and we can use the values they return to create a new object. Let's finish it off by creating the &quot;block&quot; parser, which is supposed to parse several expressions separated by newlines:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #88846F;">//Adding to the code above:</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">Dictionary</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">,</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt;&gt;&gt; block </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    expr.</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\n</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">));</span></div><textarea data-torchlight-original="true" style="display: none !important;">//Adding to the code above:
Parser&lt;IEnumerable&lt;Dictionary&lt;string,string&gt;&gt;&gt; block =
    expr.DelimitedBy(Parse.Char('\n'));
</textarea></code></pre>
<p>Notice  how we are not using the fancy LINQ expressions here. Because our parser fits on one line, and <em>DelimitedBy</em> returns the type that we want, then we can condense our parser a bit. Now that we're done with our parser, we should be able to parse our example file just fine into an <em>IEnumberable</em> of dictionaries containing our identifier-string pairs.</p>
</section>
<section id="comma-separated-values">
<h2>Comma-Separated Values <a class="section-link" href="https://ian.wold.guru/Posts/sprache.html#comma-separated-values">#</a></h2>
<p>CSV files are extremely popular for storing tables in plaintext, and they're very easy to parse, as you might imagine. Frequently, programs which read from CSV files desire to read the files into their own data structures. So, we'll imagine a couple different scenarios involving CSVs, and we'll look at how we can go about parsing each one.</p>
<p>First, I'll provide a rough CSV parser that sorts the CSV into a list of a list of strings, and from there we can talk about a custom data structure for it.</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt;&gt;&gt; csv </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> </span></div><div class='line'><span style="color: #F8F8F2;">    Parse.AnyChar.</span><span style="color: #A6E22E;">Except</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\n</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">))).</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">())</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\n</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">));</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;IEnumerable&lt;IEnumerable&lt;string&gt;&gt;&gt; csv = 
    Parse.AnyChar.Except(Parse.Char(',')
        .Or(Parse.Char('\n'))).Many().Text()
        .DelimitedBy(Parse.Char(',').Token())
        .DelimitedBy(Parse.Char('\n'));
</textarea></code></pre>
<p>This parser is quite fun, as it can be written in one line, yet it parses a CSV file pretty much alright - you might notice that none of the values can contain a comma (Bonus problem: see if you can get the parser to recognize escape characters so that the user can insert commas. Later, in the JSON parser, we'll implement escape characters).</p>
<p>Let's digress now, and suppose we have the following simplistic data structure:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F92672;">class</span><span style="color: #F8F8F2;"> </span><span style="color: #A6E22E;">Row</span></div><div class='line'><span style="color: #F8F8F2;">{</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;"> Title { </span><span style="color: #F92672;">get</span><span style="color: #F8F8F2;">; </span><span style="color: #F92672;">set</span><span style="color: #F8F8F2;">; }</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt; Items { </span><span style="color: #F92672;">get</span><span style="color: #F8F8F2;">; </span><span style="color: #F92672;">set</span><span style="color: #F8F8F2;">; }</span></div><div class='line'><span style="color: #F8F8F2;">}</span></div><textarea data-torchlight-original="true" style="display: none !important;">class Row
{
    public string Title { get; set; }
    public IEnumerable&lt;string&gt; Items { get; set; }
}
</textarea></code></pre>
<p>And let's further suppose that in a CSV, the first item of every row is the title of that row, and the remaining elements in that row are the items, corresponding to the structure above. So, we want to get a list of these rows, presumably. We can very easily modify our parser:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">Row</span><span style="color: #F8F8F2;">&gt; line </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> first </span><span style="color: #F92672;">in</span></div><div class='line'><span style="color: #F8F8F2;">        Parse.AnyChar</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">Except</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\n</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">)))</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> comma </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> rest </span><span style="color: #F92672;">in</span></div><div class='line'><span style="color: #F8F8F2;">        Parse.AnyChar</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">Except</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\n</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">))).</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">())</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">Row</span><span style="color: #F8F8F2;">() { Title </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> first, Items </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> rest };</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">Row</span><span style="color: #F8F8F2;">&gt;&gt; csv </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> line.</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\n</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">));</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;Row&gt; line =
    from first in
        Parse.AnyChar
        .Except(Parse.Char(',')
        .Or(Parse.Char('\n')))
        .Many().Text()
    from comma in Parse.Char(',').Token()
    from rest in
        Parse.AnyChar
        .Except(Parse.Char(',')
        .Or(Parse.Char('\n'))).Many().Text()
        .DelimitedBy(Parse.Char(',').Token())
    select new Row() { Title = first, Items = rest };
Parser&lt;IEnumerable&lt;Row&gt;&gt; csv = line.DelimitedBy(Parse.Char('\n'));
</textarea></code></pre>
<p>Naturally, if you're just interested in obtaining the rows, then this parser works perfectly. But let's suppose we didn't want the nested lists to contain the rows, but the columns. In this case, we can do some nifty snafu:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt;&gt; line </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    Parse.AnyChar.</span><span style="color: #A6E22E;">Except</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\n</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">))).</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">        .</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">());</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt;&gt;&gt; csv </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> l </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> line.</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\n</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">))</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #A6E22E;">Transform</span><span style="color: #F8F8F2;">(l);</span></div><div class='line'><span style="color: #88846F;">//Here&#39;s the Transform method:</span></div><div class='line'><span style="color: #88846F;">//Assume the table is n-by-n</span></div><div class='line'><span style="color: #F92672;">static</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt;&gt; </span><span style="color: #A6E22E;">Transform</span><span style="color: #F8F8F2;">(</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt;&gt; t)</span></div><div class='line'><span style="color: #F8F8F2;">{</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">var</span><span style="color: #F8F8F2;"> toReturn </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">List</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">List</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt;&gt;();</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">for</span><span style="color: #F8F8F2;"> (</span><span style="color: #F92672;">int</span><span style="color: #F8F8F2;"> i </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> </span><span style="color: #AE81FF;">0</span><span style="color: #F8F8F2;">; i </span><span style="color: #F92672;">&lt;</span><span style="color: #F8F8F2;"> t.</span><span style="color: #A6E22E;">ElementAt</span><span style="color: #F8F8F2;">(</span><span style="color: #AE81FF;">0</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Count</span><span style="color: #F8F8F2;">(); i</span><span style="color: #F92672;">++</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">    {</span></div><div class='line'><span style="color: #F8F8F2;">        </span><span style="color: #F92672;">for</span><span style="color: #F8F8F2;"> (</span><span style="color: #F92672;">int</span><span style="color: #F8F8F2;"> j </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> </span><span style="color: #AE81FF;">0</span><span style="color: #F8F8F2;">; j </span><span style="color: #F92672;">&lt;</span><span style="color: #F8F8F2;"> t.</span><span style="color: #A6E22E;">Count</span><span style="color: #F8F8F2;">(); j</span><span style="color: #F92672;">++</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">        {</span></div><div class='line'><span style="color: #F8F8F2;">            </span><span style="color: #F92672;">if</span><span style="color: #F8F8F2;"> (toReturn.Count </span><span style="color: #F92672;">==</span><span style="color: #F8F8F2;"> i) toReturn.</span><span style="color: #A6E22E;">Add</span><span style="color: #F8F8F2;">(new List</span><span style="color: #F92672;">&lt;</span><span style="color: #F8F8F2;">string</span><span style="color: #F92672;">&gt;</span><span style="color: #F8F8F2;">);</span></div><div class='line'><span style="color: #F8F8F2;">            </span><span style="color: #F92672;">if</span><span style="color: #F8F8F2;"> (toReturn[i].Count </span><span style="color: #F92672;">==</span><span style="color: #F8F8F2;"> j) toReturn[i].</span><span style="color: #A6E22E;">Add</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;&quot;</span><span style="color: #F8F8F2;">);</span></div><div class='line'><span style="color: #F8F8F2;">            toReturn[i][j] </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> t.</span><span style="color: #A6E22E;">ElementAt</span><span style="color: #F8F8F2;">(j).</span><span style="color: #A6E22E;">ElementAt</span><span style="color: #F8F8F2;">(i);</span></div><div class='line'><span style="color: #F8F8F2;">        }</span></div><div class='line'><span style="color: #F8F8F2;">    }</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">return</span><span style="color: #F8F8F2;"> toReturn;</span></div><div class='line'><span style="color: #F8F8F2;">}</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;IEnumerable&lt;string&gt;&gt; line =
    Parse.AnyChar.Except(Parse.Char(',')
        .Or(Parse.Char('\n'))).Many().Text()
        .DelimitedBy(Parse.Char(',').Token());
Parser&lt;IEnumerable&lt;IEnumerable&lt;string&gt;&gt;&gt; csv =
    from l in line.DelimitedBy(Parse.Char('\n'))
    select Transform(l);
//Here's the Transform method:
//Assume the table is n-by-n
static IEnumerable&lt;IEnumerable&lt;string&gt;&gt; Transform(IEnumerable&lt;IEnumerable&lt;string&gt;&gt; t)
{
    var toReturn = new List&lt;List&lt;string&gt;&gt;();
    for (int i = 0; i &lt; t.ElementAt(0).Count(); i++)
    {
        for (int j = 0; j &lt; t.Count(); j++)
        {
            if (toReturn.Count == i) toReturn.Add(new List&lt;string&gt;);
            if (toReturn[i].Count == j) toReturn[i].Add("");
            toReturn[i][j] = t.ElementAt(j).ElementAt(i);
        }
    }
    return toReturn;
}
</textarea></code></pre>
<p><em>Transform</em> just rotates the list of lists as though it's a matrix, so we're not adding anything too special here. What if we wanted to do what we did above with the rows, but with the columns? Try modifying this code to do just that. Bonus points if you can eliminate <em>Transform</em> and perform the transformation within the parser!</p>
</section>
<section id="xml">
<h2>XML <a class="section-link" href="https://ian.wold.guru/Posts/sprache.html#xml">#</a></h2>
<p>Obviously, XML is a rather complex language, and a <a href="http://www.w3.org/TR/REC-xml/">complete BNF specification</a> is thus very large. Therefore, we'll be using a much simpler variation of XML, which we can see below:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-bnf"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">&lt;tag&gt; ::= &lt;single_line_tag&gt; | &lt;multi_line_tag&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;short_tag&gt; ::= &quot;&lt;&quot; &lt;identifier&gt; &lt;whitespace&gt; &lt;attribute&gt;* &quot;/&gt;&quot;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;full_tag&gt; ::= &quot;&lt;&quot; &lt;identifier&gt; &lt;whitespace&gt; &lt;attribute&gt;* &quot;&gt;&quot; &lt;tag&gt;*</span></div><div class='line'><span style="color: #F8F8F2;">    &quot;&lt;/&quot; &lt;identifier&gt; &quot;&gt;&quot;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;attribute&gt; ::= &lt;identifier&gt; &quot;=&quot; &quot;\&quot;&quot; &lt;any_characters&gt; &quot;\&quot;&quot;</span></div><textarea data-torchlight-original="true" style="display: none !important;">&lt;tag&gt; ::= &lt;single_line_tag&gt; | &lt;multi_line_tag&gt;
&lt;short_tag&gt; ::= "&lt;" &lt;identifier&gt; &lt;whitespace&gt; &lt;attribute&gt;* "/&gt;"
&lt;full_tag&gt; ::= "&lt;" &lt;identifier&gt; &lt;whitespace&gt; &lt;attribute&gt;* "&gt;" &lt;tag&gt;*
    "&lt;/" &lt;identifier&gt; "&gt;"
&lt;attribute&gt; ::= &lt;identifier&gt; "=" "\"" &lt;any_characters&gt; "\""
</textarea></code></pre>
<p>You might notice I'm leaving out a few unnecessary components: Expressions which are intuitively obvious aren't defined, <em>whitespace</em> is only used where necessary (we'll use <em>Token</em> prolifically to allow for flexibility on the user's part), and when defining a &quot;full&quot; tag, the identifier of the opening and closing tags must be the same. The latter component cannot be defined in vanilla BNF, so it's something we'll need to account for in our code.</p>
<p>Instead of writing this code out, I'll reference the <a href="https://github.com/sprache/Sprache/blob/master/src/XmlExample/Program.cs">XML example</a> which is included with Sprache, and I'll explain the new elements and solutions found there.</p>
<p>Right off the bat, looking at the <em>Document</em> parser, we're introduced to a new use of LINQ. As I alluded to previously, any LINQ query can be written in one line without the LINQ statements. Here's the critical portion of line 98:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">Node.</span><span style="color: #A6E22E;">Select</span><span style="color: #F8F8F2;">(n </span><span style="color: #F92672;">=&gt;</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">Document</span><span style="color: #F8F8F2;"> { Root </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> n })</span></div><textarea data-torchlight-original="true" style="display: none !important;">Node.Select(n =&gt; new Document { Root = n })
</textarea></code></pre>
<p>To make this easier to comprehend, we can write it out using the regular LINQ notation we're familiar with:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> n </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Node</span></div><div class='line'><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">Document</span><span style="color: #F8F8F2;">() { Root </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> n };</span></div><textarea data-torchlight-original="true" style="display: none !important;">from n in Node
select new Document() { Root = n };
</textarea></code></pre>
<p>In fact, the LINQ statements we've been are just a shorthand (or perhaps more of a &quot;paraphrasing,&quot; as they tend to be longer) for the inline notation. <em>Document</em>
very well could have been written using solely the LINQ statements, and that would have looked like this:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">static</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">readonly</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">Document</span><span style="color: #F8F8F2;">&gt; Document </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> leading </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.WhiteSpace.</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> doc </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> n </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Node.</span><span style="color: #A6E22E;">End</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">                </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">Document</span><span style="color: #F8F8F2;">() { Root </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> n }</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> doc;</span></div><textarea data-torchlight-original="true" style="display: none !important;">public static readonly Parser&lt;Document&gt; Document =
    from leading in Parse.WhiteSpace.Many()
    from doc in from n in Node.End()
                select new Document() { Root = n }
    select doc;
</textarea></code></pre>
<p>The next parser up from <em>Document</em> is <em>Item</em>. We'll ignore the code regarding the comments (if you're interested in this, please see my post <a href="https://ianwold.silvrback.com/parsing-comments-with-sprache">Parsing Comments with Sprache</a>). This makes it easy to see that an <em>Item</em> is either a <em>Node</em> cast as an Item, or a <em>Content</em>, and a <em>Node</em> (looking above in the document) is either a short or full node.</p>
<p>Looking at the <em>ShortNode</em> parser, we can see it seems completely familiar, except that the LINQ expression is used as an argument to the <em>Tag</em> method. The <em>Tag</em> method returns a parser that parses a greater than and less than sign before and after the parser you specify. This abstraction allows us to write cleaner code.</p>
<p><em>FullNode</em> is fun for a couple reasons. First, look at how they solved the issue of requiring opening and closing tags to be named the same with the <em>EndTag</em> method. In addition, notice the use of the <em>Ref</em> parser. In <em>FullNode</em>, we need to use <em>Item</em>, but it has obviously not yet been created. <em>Ref</em> allows us to reference a parser later in the document, thus allowing us to create some recursive or ambiguous grammars with Sprache.</p>
</section>
<section id="json">
<h2>JSON <a class="section-link" href="https://ian.wold.guru/Posts/sprache.html#json">#</a></h2>
<p>JSON, or JavaScript Object Notation, is kind of like XML. It's a way of storing data in plaintext (in a key-value pair manner) which is also easily readable by a human. In addition, it's very easy to construct a parser for it. The BNF form is very clear and concise - here, I have transcribed the <a href="http://json.org/">informal definition on json.org</a> into the more formal BNF notation which we have been using in this tutorial:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-bnf"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">&lt;object&gt;    ::= &quot;{}&quot; | &quot;{&quot; &lt;members&gt; &quot;}&quot;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;members&gt;   ::= &lt;pair&gt; | &lt;pair&gt; &quot;,&quot; &lt;members&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;pair&gt;      ::= &lt;string&gt; &quot;:&quot; &lt;value&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;array&gt;     ::= &quot;[]&quot; | &quot;[&quot; &lt;elements&gt; &quot;]&quot;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;elements&gt;  ::= &lt;value&gt; | &lt;value&gt; &quot;,&quot; &lt;elements&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;value&gt;     ::= &lt;literal&gt; | &lt;array&gt; | &lt;object&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;literal&gt;   ::= &lt;string&gt; | &lt;number&gt; | &lt;bool&gt; | &quot;null&quot;</span></div><textarea data-torchlight-original="true" style="display: none !important;">&lt;object&gt;    ::= "{}" | "{" &lt;members&gt; "}"
&lt;members&gt;   ::= &lt;pair&gt; | &lt;pair&gt; "," &lt;members&gt;
&lt;pair&gt;      ::= &lt;string&gt; ":" &lt;value&gt;
&lt;array&gt;     ::= "[]" | "[" &lt;elements&gt; "]"
&lt;elements&gt;  ::= &lt;value&gt; | &lt;value&gt; "," &lt;elements&gt;
&lt;value&gt;     ::= &lt;literal&gt; | &lt;array&gt; | &lt;object&gt;
&lt;literal&gt;   ::= &lt;string&gt; | &lt;number&gt; | &lt;bool&gt; | "null"
</textarea></code></pre>
<p>An example of a valid JSON file might be the following:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-json"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">{</span></div><div class='line'><span style="color: #F8F8F2;">  </span><span style="color: #66D9EF;">&quot;firstName&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #CFCFC2;">&quot;John&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">  </span><span style="color: #66D9EF;">&quot;lastName&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #CFCFC2;">&quot;Smith&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">  </span><span style="color: #66D9EF;">&quot;age&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #AE81FF;">25</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">  </span><span style="color: #66D9EF;">&quot;address&quot;</span><span style="color: #F8F8F2;">: {</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #66D9EF;">&quot;streetAddress&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #CFCFC2;">&quot;21 2nd Street&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #66D9EF;">&quot;city&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #CFCFC2;">&quot;New York&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #66D9EF;">&quot;state&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #CFCFC2;">&quot;NY&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #66D9EF;">&quot;postalCode&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #CFCFC2;">&quot;10021-3100&quot;</span></div><div class='line'><span style="color: #F8F8F2;">  },</span></div><div class='line'><span style="color: #F8F8F2;">  </span><span style="color: #66D9EF;">&quot;phoneNumbers&quot;</span><span style="color: #F8F8F2;">: [</span></div><div class='line'><span style="color: #F8F8F2;">    {</span></div><div class='line'><span style="color: #F8F8F2;">      </span><span style="color: #66D9EF;">&quot;type&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #CFCFC2;">&quot;home&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">      </span><span style="color: #66D9EF;">&quot;number&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #CFCFC2;">&quot;212 555-1234&quot;</span></div><div class='line'><span style="color: #F8F8F2;">    },</span></div><div class='line'><span style="color: #F8F8F2;">    {</span></div><div class='line'><span style="color: #F8F8F2;">      </span><span style="color: #66D9EF;">&quot;type&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #CFCFC2;">&quot;office&quot;</span><span style="color: #F8F8F2;">,</span></div><div class='line'><span style="color: #F8F8F2;">      </span><span style="color: #66D9EF;">&quot;number&quot;</span><span style="color: #F8F8F2;">: </span><span style="color: #CFCFC2;">&quot;646 555-4567&quot;</span></div><div class='line'><span style="color: #F8F8F2;">    }</span></div><div class='line'><span style="color: #F8F8F2;">  ]</span></div><div class='line'><span style="color: #F8F8F2;">}</span></div><textarea data-torchlight-original="true" style="display: none !important;">{
  "firstName": "John",
  "lastName": "Smith",
  "age": 25,
  "address": {
    "streetAddress": "21 2nd Street",
    "city": "New York",
    "state": "NY",
    "postalCode": "10021-3100"
  },
  "phoneNumbers": [
    {
      "type": "home",
      "number": "212 555-1234"
    },
    {
      "type": "office",
      "number": "646 555-4567"
    }
  ]
}
</textarea></code></pre>
<p>This should allow us to construct the data structure we're going to store our data in (called an Abstract Syntax Tree):</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'>&nbsp;</div><div class='line'><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">class</span><span style="color: #F8F8F2;"> </span><span style="color: #A6E22E;">JSONValue</span><span style="color: #F8F8F2;"> {}</span></div><div class='line'><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">class</span><span style="color: #F8F8F2;"> </span><span style="color: #A6E22E;">JSONObject</span><span style="color: #F8F8F2;"> : </span><span style="color: #66D9EF;">JSONValue</span></div><div class='line'><span style="color: #F8F8F2;">{</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">Dictionary</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">, </span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt; Pairs { </span><span style="color: #F92672;">get</span><span style="color: #F8F8F2;">; </span><span style="color: #F92672;">set</span><span style="color: #F8F8F2;">; }</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #A6E22E;">JSONObject</span><span style="color: #F8F8F2;">(</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">KeyValuePair</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">, </span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt;&gt; pairs)</span></div><div class='line'><span style="color: #F8F8F2;">    {</span></div><div class='line'><span style="color: #F8F8F2;">        Pairs </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">Dictionary</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">, </span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt;();</span></div><div class='line'><span style="color: #F8F8F2;">        </span><span style="color: #F92672;">if</span><span style="color: #F8F8F2;"> (pairs </span><span style="color: #F92672;">!=</span><span style="color: #F8F8F2;"> </span><span style="color: #AE81FF;">null</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">            </span><span style="color: #F92672;">foreach</span><span style="color: #F8F8F2;"> (</span><span style="color: #F92672;">var</span><span style="color: #F8F8F2;"> p </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> pairs)</span></div><div class='line'><span style="color: #F8F8F2;">                Pairs.</span><span style="color: #A6E22E;">Add</span><span style="color: #F8F8F2;">(p.Key, p.Value);</span></div><div class='line'><span style="color: #F8F8F2;">    }</span></div><div class='line'><span style="color: #F8F8F2;">}</span></div><div class='line'><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">class</span><span style="color: #F8F8F2;"> </span><span style="color: #A6E22E;">JSONArray</span><span style="color: #F8F8F2;"> : </span><span style="color: #66D9EF;">JSONValue</span></div><div class='line'><span style="color: #F8F8F2;">{</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">List</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt; Elements { </span><span style="color: #F92672;">get</span><span style="color: #F8F8F2;">; </span><span style="color: #F92672;">set</span><span style="color: #F8F8F2;">; }</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #A6E22E;">JSONArray</span><span style="color: #F8F8F2;">(</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt; elements)</span></div><div class='line'><span style="color: #F8F8F2;">    {</span></div><div class='line'><span style="color: #F8F8F2;">        Elements </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">List</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt;();</span></div><div class='line'><span style="color: #F8F8F2;">        </span><span style="color: #F92672;">if</span><span style="color: #F8F8F2;"> (elements </span><span style="color: #F92672;">!=</span><span style="color: #F8F8F2;"> </span><span style="color: #AE81FF;">null</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">            </span><span style="color: #F92672;">foreach</span><span style="color: #F8F8F2;"> (</span><span style="color: #F92672;">var</span><span style="color: #F8F8F2;"> e </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> elements)</span></div><div class='line'><span style="color: #F8F8F2;">                Elements.</span><span style="color: #A6E22E;">Add</span><span style="color: #F8F8F2;">(e);</span></div><div class='line'><span style="color: #F8F8F2;">    }</span></div><div class='line'><span style="color: #F8F8F2;">}</span></div><div class='line'><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">class</span><span style="color: #F8F8F2;"> </span><span style="color: #A6E22E;">JSONLiteral</span><span style="color: #F8F8F2;"> : </span><span style="color: #66D9EF;">JSONValue</span></div><div class='line'><span style="color: #F8F8F2;">{</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;"> Value { </span><span style="color: #F92672;">get</span><span style="color: #F8F8F2;">; </span><span style="color: #F92672;">set</span><span style="color: #F8F8F2;">; }</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">LiteralType</span><span style="color: #F8F8F2;"> ValueType { </span><span style="color: #F92672;">get</span><span style="color: #F8F8F2;">; </span><span style="color: #F92672;">set</span><span style="color: #F8F8F2;">; }</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">public</span><span style="color: #F8F8F2;"> </span><span style="color: #A6E22E;">JSONLiteral</span><span style="color: #F8F8F2;">(</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;"> value, </span><span style="color: #66D9EF;">LiteralType</span><span style="color: #F8F8F2;"> type)</span></div><div class='line'><span style="color: #F8F8F2;">    {</span></div><div class='line'><span style="color: #F8F8F2;">        Value </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> value;</span></div><div class='line'><span style="color: #F8F8F2;">        ValueType </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> type;</span></div><div class='line'><span style="color: #F8F8F2;">    }</span></div><div class='line'><span style="color: #F8F8F2;">    pubilc </span><span style="color: #F92672;">static</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">enum</span><span style="color: #F8F8F2;"> </span><span style="color: #A6E22E;">LiteralType</span></div><div class='line'><span style="color: #F8F8F2;">    {</span></div><div class='line'><span style="color: #F8F8F2;">        String,</span></div><div class='line'><span style="color: #F8F8F2;">        Number,</span></div><div class='line'><span style="color: #F8F8F2;">        Boolean,</span></div><div class='line'><span style="color: #F8F8F2;">        Null</span></div><div class='line'><span style="color: #F8F8F2;">    }</span></div><div class='line'><span style="color: #F8F8F2;">}</span></div><textarea data-torchlight-original="true" style="display: none !important;">public class JSONValue {}
public class JSONObject : JSONValue
{
    public Dictionary&lt;string, JSONValue&gt; Pairs { get; set; }
    public JSONObject(IEnumerable&lt;KeyValuePair&lt;string, JSONValue&gt;&gt; pairs)
    {
        Pairs = new Dictionary&lt;string, JSONValue&gt;();
        if (pairs != null)
            foreach (var p in pairs)
                Pairs.Add(p.Key, p.Value);
    }
}
public class JSONArray : JSONValue
{
    public List&lt;JSONValue&gt; Elements { get; set; }
    public JSONArray(IEnumerable&lt;JSONValue&gt; elements)
    {
        Elements = new List&lt;JSONValue&gt;();
        if (elements != null)
            foreach (var e in elements)
                Elements.Add(e);
    }
}
public class JSONLiteral : JSONValue
{
    public string Value { get; set; }
    public LiteralType ValueType { get; set; }
    public JSONLiteral(string value, LiteralType type)
    {
        Value = value;
        ValueType = type;
    }
    pubilc static enum LiteralType
    {
        String,
        Number,
        Boolean,
        Null
    }
}
</textarea></code></pre>
<p>To implement the parser, we'll start from the bottom and work our way up, as we usually do. Literal values are expressed nicely by our JSONLiteral class, which stores every value as a string, and also keeps track of the type of literal it is. Parsing them all out is a bit of a pain, so I'll post each parser here and explain it briefly.</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONLiteral</span><span style="color: #F8F8F2;">&gt; JNull </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> str </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">IgnoreCase</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;null&quot;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">JSONLiteral</span><span style="color: #F8F8F2;">(</span><span style="color: #AE81FF;">null</span><span style="color: #F8F8F2;">, JSONLiteral.LiteralType.Null);</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONLiteral</span><span style="color: #F8F8F2;">&gt; JBoolean </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> str </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">IgnoreCase</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;true&quot;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    			.</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">IgnoreCase</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;false&quot;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">())</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">JSONLiteral</span><span style="color: #F8F8F2;">(str, LiteralType.Boolean);</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;JSONLiteral&gt; JNull =
    from str in Parse.IgnoreCase("null")
    select new JSONLiteral(null, JSONLiteral.LiteralType.Null);
Parser&lt;JSONLiteral&gt; JBoolean =
    from str in Parse.IgnoreCase("true").Text()
    			.Or(Parse.IgnoreCase("false").Text())
    select new JSONLiteral(str, LiteralType.Boolean);
</textarea></code></pre>
<p>Parsing a literal null or boolean value isn't all too complicated. We just need to parse the strings which represent them, ignoring the case, and return new JSONLiteral objects.</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt; JExp </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> e </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">IgnoreCase</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;e&quot;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> sign </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">String</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;+&quot;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">                 .</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">String</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;-&quot;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">())</span></div><div class='line'><span style="color: #F8F8F2;">                 .</span><span style="color: #A6E22E;">Optional</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> digits </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.Digit.</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> e </span><span style="color: #F92672;">+</span><span style="color: #F8F8F2;"> ((sign.IsDefined) </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> sign.</span><span style="color: #A6E22E;">Get</span><span style="color: #F8F8F2;">() </span><span style="color: #F92672;">:</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&quot;&quot;</span><span style="color: #F8F8F2;">) </span><span style="color: #F92672;">+</span><span style="color: #F8F8F2;"> digits;</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt; JFrac </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> dot </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">String</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;.&quot;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> digits </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.Digit.</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> dot </span><span style="color: #F92672;">+</span><span style="color: #F8F8F2;"> digits;</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">&gt; JInt </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> minus </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">String</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&quot;-&quot;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">Optional</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> digits </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.Digit.</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> (minus.IsDefined </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> minus.</span><span style="color: #A6E22E;">Get</span><span style="color: #F8F8F2;">() </span><span style="color: #F92672;">:</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&quot;&quot;</span><span style="color: #F8F8F2;">) </span><span style="color: #F92672;">+</span><span style="color: #F8F8F2;"> digits;</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONLiteral</span><span style="color: #F8F8F2;">&gt; JNumber </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> integer </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> JInt</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> frac </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> JFrac.</span><span style="color: #A6E22E;">Optional</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> exp </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> JExp.</span><span style="color: #A6E22E;">Optional</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">JSONLiteral</span><span style="color: #F8F8F2;">(integer </span><span style="color: #F92672;">+</span></div><div class='line'><span style="color: #F8F8F2;">                           (frac.IsDefined </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> frac.</span><span style="color: #A6E22E;">Get</span><span style="color: #F8F8F2;">() </span><span style="color: #F92672;">:</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&quot;&quot;</span><span style="color: #F8F8F2;">) </span><span style="color: #F92672;">+</span></div><div class='line'><span style="color: #F8F8F2;">                           (exp.IsDefined </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> exp.</span><span style="color: #A6E22E;">Get</span><span style="color: #F8F8F2;">() </span><span style="color: #F92672;">:</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&quot;&quot;</span><span style="color: #F8F8F2;">),</span></div><div class='line'><span style="color: #F8F8F2;">                           LiteralType.Number);</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;string&gt; JExp =
    from e in Parse.IgnoreCase("e").Text()
    from sign in Parse.String("+").Text()
                 .Or(Parse.String("-").Text())
                 .Optional()
    from digits in Parse.Digit.Many().Text()
    select e + ((sign.IsDefined) ? sign.Get() : "") + digits;
Parser&lt;string&gt; JFrac =
    from dot in Parse.String(".").Text()
    from digits in Parse.Digit.Many().Text()
    select dot + digits;
Parser&lt;string&gt; JInt =
    from minus in Parse.String("-").Text().Optional()
    from digits in Parse.Digit.Many().Text()
    select (minus.IsDefined ? minus.Get() : "") + digits;
Parser&lt;JSONLiteral&gt; JNumber =
    from integer in JInt
    from frac in JFrac.Optional()
    from exp in JExp.Optional()
    select new JSONLiteral(integer +
                           (frac.IsDefined ? frac.Get() : "") +
                           (exp.IsDefined ? exp.Get() : ""),
                           LiteralType.Number);
</textarea></code></pre>
<p>Parsing a number is much more exciting. We need to account for integers, decimals, negation, and 'e'. The code above for <em>JNumber</em> knows we need at least an integer, and can be optionally followed by the fraction or the exponential term. Notice that <em>Optional</em> returns a special object which may or may not be defined. Thus, we need to check whether it is defined with <em>IsDefined</em> before we can <em>Get</em> its value.</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">List</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">char</span><span style="color: #F8F8F2;">&gt; EscapeChars </span><span style="color: #F92672;">=</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">List</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">char</span><span style="color: #F8F8F2;">&gt;</span></div><div class='line'><span style="color: #F8F8F2;">    { </span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\&quot;</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">, </span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\\</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">, </span><span style="color: #E6DB74;">&#39;b&#39;</span><span style="color: #F8F8F2;">, </span><span style="color: #E6DB74;">&#39;f&#39;</span><span style="color: #F8F8F2;">, </span><span style="color: #E6DB74;">&#39;n&#39;</span><span style="color: #F8F8F2;">, </span><span style="color: #E6DB74;">&#39;r&#39;</span><span style="color: #F8F8F2;">, </span><span style="color: #E6DB74;">&#39;t&#39;</span><span style="color: #F8F8F2;"> };</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">char</span><span style="color: #F8F8F2;">&gt; ControlChar </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> first </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\\</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> next </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">EnumerateInput</span><span style="color: #F8F8F2;">(EscapeChars, c </span><span style="color: #F92672;">=&gt;</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(c))</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> ((next </span><span style="color: #F92672;">==</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;t&#39;</span><span style="color: #F8F8F2;">) </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\t</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">:</span></div><div class='line'><span style="color: #F8F8F2;">            (next </span><span style="color: #F92672;">==</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;r&#39;</span><span style="color: #F8F8F2;">) </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\r</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">:</span></div><div class='line'><span style="color: #F8F8F2;">            (next </span><span style="color: #F92672;">==</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;n&#39;</span><span style="color: #F8F8F2;">) </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\n</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">:</span></div><div class='line'><span style="color: #F8F8F2;">            (next </span><span style="color: #F92672;">==</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;f&#39;</span><span style="color: #F8F8F2;">) </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\f</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">:</span></div><div class='line'><span style="color: #F8F8F2;">            (next </span><span style="color: #F92672;">==</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;b&#39;</span><span style="color: #F8F8F2;">) </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> </span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\b</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">:</span></div><div class='line'><span style="color: #F8F8F2;">            next );</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">char</span><span style="color: #F8F8F2;">&gt; JChar </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    Parse.AnyChar</span></div><div class='line'><span style="color: #F8F8F2;">    .</span><span style="color: #A6E22E;">Except</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;&quot;&#39;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">    .</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\\</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">)))</span></div><div class='line'><span style="color: #F8F8F2;">    .</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(ControlChar);</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONLiteral</span><span style="color: #F8F8F2;">&gt; JString </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> first </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;&quot;&#39;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> chars </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> JChar.</span><span style="color: #A6E22E;">Many</span><span style="color: #F8F8F2;">().</span><span style="color: #A6E22E;">Text</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> last </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;&quot;&#39;</span><span style="color: #F8F8F2;">)</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">JSONLiteral</span><span style="color: #F8F8F2;">(chars, LiteralType.String);</span></div><textarea data-torchlight-original="true" style="display: none !important;">List&lt;char&gt; EscapeChars = new List&lt;char&gt;
    { '\"', '\\', 'b', 'f', 'n', 'r', 't' };
Parser&lt;char&gt; ControlChar =
    from first in Parse.Char('\\')
    from next in Parse.EnumerateInput(EscapeChars, c =&gt; Parse.Char(c))
    select ((next == 't') ? '\t' :
            (next == 'r') ? '\r' :
            (next == 'n') ? '\n' :
            (next == 'f') ? '\f' :
            (next == 'b') ? '\b' :
            next );
Parser&lt;char&gt; JChar =
    Parse.AnyChar
    .Except(Parse.Char('"')
    .Or(Parse.Char('\\')))
    .Or(ControlChar);
Parser&lt;JSONLiteral&gt; JString =
    from first in Parse.Char('"')
    from chars in JChar.Many().Text()
    from last in Parse.Char('"')
    select new JSONLiteral(chars, LiteralType.String);
</textarea></code></pre>
<p>To parse a string, we want to make sure that we allow for control characters (the control characters are all given on <a href="http://json.org">json.org</a>). As you can see, the string will be zero or more characters, which are in turn any character except a quotation mark or the escape character. Where <em>ControlChar</em> is defined, <em>EnumerateInput</em> is used on our list <em>EscapeChars</em>. This instance of <em>EnumerateInput</em> will return the following parser:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">( </span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\&quot;</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;</span><span style="color: #AE81FF;">\\</span><span style="color: #E6DB74;">&#39;</span><span style="color: #F8F8F2;">)).</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;b&#39;</span><span style="color: #F8F8F2;">)) ...</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parse.Char( '\"').Or(Parse.Char('\\')).Or(Parse.Char('b')) ...
</textarea></code></pre>
<p>That is, it chains each element in <em>EscapeChars</em> along as the parser <em>Parse.Char()</em> using the <em>Or</em> parser.</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONLiteral</span><span style="color: #F8F8F2;">&gt; JLiteral </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    JString</span></div><div class='line'><span style="color: #F8F8F2;">    .</span><span style="color: #A6E22E;">XOr</span><span style="color: #F8F8F2;">(JNumber)</span></div><div class='line'><span style="color: #F8F8F2;">    .</span><span style="color: #A6E22E;">XOr</span><span style="color: #F8F8F2;">(JBoolean)</span></div><div class='line'><span style="color: #F8F8F2;">    .</span><span style="color: #A6E22E;">XOr</span><span style="color: #F8F8F2;">(JNull);</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;JSONLiteral&gt; JLiteral =
    JString
    .XOr(JNumber)
    .XOr(JBoolean)
    .XOr(JNull);
</textarea></code></pre>
<p>Finally, we're able to piece them all together to form our <em>JLiteral</em> parser. Luckily, this is half of our entire parser!</p>
<p>As you can see from our JSON BNF, the rest of the grammar is recursive. That is, self-referential. This is where <em>Ref</em> will come in handy. We need to implement objects and arrays, and those two <strong>plus</strong> literals will be defined as a value. So, let's define our <em>JValue</em> parser, and proceed from there.</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt; JValue </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    Parse.</span><span style="color: #A6E22E;">Ref</span><span style="color: #F8F8F2;">(() </span><span style="color: #F92672;">=&gt;</span><span style="color: #F8F8F2;"> JObject)</span></div><div class='line'><span style="color: #F8F8F2;">    .</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Ref</span><span style="color: #F8F8F2;">(() </span><span style="color: #F92672;">=&gt;</span><span style="color: #F8F8F2;"> JArray))</span></div><div class='line'><span style="color: #F8F8F2;">    .</span><span style="color: #A6E22E;">Or</span><span style="color: #F8F8F2;">(JLiteral);</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;JSONValue&gt; JValue =
    Parse.Ref(() =&gt; JObject)
    .Or(Parse.Ref(() =&gt; JArray))
    .Or(JLiteral);
</textarea></code></pre>
<p>Here, we are using <em>Ref</em> to reference our yet-undefined <em>JObject</em> and <em>JArray</em> parsers. Of course, we've already created our <em>JLiteral</em> parser, so we do not need to use <em>Ref</em> to access it.</p>
<p>Now we just need to parse JSON arrays and objects. For convenience, let's recall the portion of the JSON BNF which defined them:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-bnf"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #F8F8F2;">&lt;object&gt;    ::= &quot;{}&quot; | &quot;{&quot; &lt;members&gt; &quot;}&quot;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;members&gt;   ::= &lt;pair&gt; | &lt;pair&gt; &quot;,&quot; &lt;members&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;pair&gt;      ::= &lt;string&gt; &quot;:&quot; &lt;value&gt;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;array&gt;     ::= &quot;[]&quot; | &quot;[&quot; &lt;elements&gt; &quot;]&quot;</span></div><div class='line'><span style="color: #F8F8F2;">&lt;elements&gt;  ::= &lt;value&gt; | &lt;value&gt; &quot;,&quot; &lt;elements&gt;</span></div><textarea data-torchlight-original="true" style="display: none !important;">&lt;object&gt;    ::= "{}" | "{" &lt;members&gt; "}"
&lt;members&gt;   ::= &lt;pair&gt; | &lt;pair&gt; "," &lt;members&gt;
&lt;pair&gt;      ::= &lt;string&gt; ":" &lt;value&gt;
&lt;array&gt;     ::= "[]" | "[" &lt;elements&gt; "]"
&lt;elements&gt;  ::= &lt;value&gt; | &lt;value&gt; "," &lt;elements&gt;
</textarea></code></pre>
<p>We can see that <em>arrray</em> and <em>object</em> look very much alike, and the definition of <em>array</em> appears to be a tad more simple. Therefore, we should write our <em>array</em> parser first, and we can copy it down to create our slightly more complicated <em>object</em> parser.</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt;&gt; JElements </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    JValue.</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">());</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt; JArray </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> first </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;[&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> elements </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> JElements.</span><span style="color: #A6E22E;">Optional</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> last </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;]&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">JSONArray</span><span style="color: #F8F8F2;">(elements.IsDefined </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> elements.</span><span style="color: #A6E22E;">Get</span><span style="color: #F8F8F2;">() </span><span style="color: #F92672;">:</span><span style="color: #F8F8F2;"> </span><span style="color: #AE81FF;">null</span><span style="color: #F8F8F2;">);</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;IEnumerable&lt;JSONValue&gt;&gt; JElements =
    JValue.DelimitedBy(Parse.Char(',').Token());
Parser&lt;JSONValue&gt; JArray =
    from first in Parse.Char('[').Token()
    from elements in JElements.Optional()
    from last in Parse.Char(']').Token()
    select new JSONArray(elements.IsDefined ? elements.Get() : null);
</textarea></code></pre>
<p>Notice how our <em>JElements</em> parser almost perfectly matches the definition of <em>elements</em> in the BNF. <em>DelimitedBy</em> will parse any number of <em>JValue</em> here, so long as they are separated by commas - this removes our need to call <em>JElements</em> recursively. Our <em>JArray</em> parser, then, just encases the <em>JElements</em> parser in square brackets. If we desired we could combine the parsers into one. The reason I separated them here, however, was to demonstrate the close relationship between BNF and parsers like Sprache. Here is how the combined parsers would look:</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt; JArray </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> first </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;[&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> elements </span><span style="color: #F92672;">in</span></div><div class='line'><span style="color: #F8F8F2;">        JValue.</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">()).</span><span style="color: #A6E22E;">Optional</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> last </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;]&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">JSONArray</span><span style="color: #F8F8F2;">(elements.IsDefined </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> elements.</span><span style="color: #A6E22E;">Get</span><span style="color: #F8F8F2;">() </span><span style="color: #F92672;">:</span><span style="color: #F8F8F2;"> </span><span style="color: #AE81FF;">null</span><span style="color: #F8F8F2;">);</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;JSONValue&gt; JArray =
    from first in Parse.Char('[').Token()
    from elements in
        JValue.DelimitedBy(Parse.Char(',').Token()).Optional()
    from last in Parse.Char(']').Token()
    select new JSONArray(elements.IsDefined ? elements.Get() : null);
</textarea></code></pre>
<p>Now, we can move on to write our <em>JObject</em> parser.</p>
<pre class="torchlight" style="background-color: #272822; --theme-selection-background: #878b9180;" data-torchlight-processed="3449c9e5e332f1dbb81505cd739fbf3f"><code class="language-c#"><!-- Syntax highlighted by torchlight.dev --><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">KeyValuePair</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">, </span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt;&gt; JPair </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> name </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> JString</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> colon </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;:&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> val </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> JValue</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">KeyValuePair</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">, </span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt;(name.Value, val);</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">IEnumerable</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">KeyValuePair</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #F92672;">string</span><span style="color: #F8F8F2;">, </span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt;&gt;&gt; JMembers </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    JPair.</span><span style="color: #A6E22E;">DelimitedBy</span><span style="color: #F8F8F2;">(Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;,&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">());</span></div><div class='line'><span style="color: #66D9EF;">Parser</span><span style="color: #F8F8F2;">&lt;</span><span style="color: #66D9EF;">JSONValue</span><span style="color: #F8F8F2;">&gt; JObject </span><span style="color: #F92672;">=</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> first </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;{&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> members </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> JMembers.</span><span style="color: #A6E22E;">Optional</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">from</span><span style="color: #F8F8F2;"> last </span><span style="color: #F92672;">in</span><span style="color: #F8F8F2;"> Parse.</span><span style="color: #A6E22E;">Char</span><span style="color: #F8F8F2;">(</span><span style="color: #E6DB74;">&#39;}&#39;</span><span style="color: #F8F8F2;">).</span><span style="color: #A6E22E;">Token</span><span style="color: #F8F8F2;">()</span></div><div class='line'><span style="color: #F8F8F2;">    </span><span style="color: #F92672;">select</span><span style="color: #F8F8F2;"> </span><span style="color: #F92672;">new</span><span style="color: #F8F8F2;"> </span><span style="color: #66D9EF;">JSONObject</span><span style="color: #F8F8F2;">(members.IsDefined </span><span style="color: #F92672;">?</span><span style="color: #F8F8F2;"> members.</span><span style="color: #A6E22E;">Get</span><span style="color: #F8F8F2;">() </span><span style="color: #F92672;">:</span><span style="color: #F8F8F2;"> </span><span style="color: #AE81FF;">null</span><span style="color: #F8F8F2;">);</span></div><textarea data-torchlight-original="true" style="display: none !important;">Parser&lt;KeyValuePair&lt;string, JSONValue&gt;&gt; JPair =
    from name in JString
    from colon in Parse.Char(':').Token()
    from val in JValue
    select new KeyValuePair&lt;string, JSONValue&gt;(name.Value, val);
Parser&lt;IEnumerable&lt;KeyValuePair&lt;string, JSONValue&gt;&gt;&gt; JMembers =
    JPair.DelimitedBy(Parse.Char(',').Token());
Parser&lt;JSONValue&gt; JObject =
    from first in Parse.Char('{').Token()
    from members in JMembers.Optional()
    from last in Parse.Char('}').Token()
    select new JSONObject(members.IsDefined ? members.Get() : null);
</textarea></code></pre>
<p>By now, this should all be trivial to you - especially considering <em>JObject</em> and <em>JMembers</em> are copies of <em>JArray</em> and <em>JElements</em>, respectively. With that, we should now be able to parse any document which conforms to the JSON standard. Notice that every JSON document is itself a single JSON object. Thus, given a JSON document, we would parse it with our <em>JObject</em> parser.</p>
<p>If you would like to see the parser in full, there is a version <a href="https://github.com/IanWold/SpracheJSON/blob/master/SpracheJSON/JSONParser.cs">on my GitHub</a>.</p>
</section>
</section>
<section id="my-work-with-sprache">
<h1>My Work With Sprache <a class="section-link" href="https://ian.wold.guru/Posts/sprache.html#my-work-with-sprache">#</a></h1>
<p>As I mentioned above, I've been working with Sprache for three years now, after seeing a presentation about it at the <a href="http://twincitiescodecamp.com/">Twin Cities Code Camp</a>, which is totally awesome and you should all go (it's even free).</p>
<p>I've contributed to Sprache by adding a <a href="https://ianwold.silvrback.com/parsing-comments-with-sprache">comment parser</a>, I've published a <a href="https://github.com/IanWold/SpracheJSON">JSON serializer/mapper</a>, and I'm working on a <a href="https://github.com/IanWold/SpracheDown">Markdown parser</a>.</p>
<p>I've used Sprache in small amounts in a couple other projects, and I enjoy using it wherever I'm able. An idea suggested to me at an <a href="http://iowacodecamp.com/">Iowa Code Camp</a>, which is also awesome and free and you should all go, was to write a tool to convert BNF into Sprache. I haven't done anything with this concept yet, but that is further work that could be done - if you're feeling the Sprache bug and you want to tackle that, go right ahead!</p>
<section id="further-reading">
<h2>Further Reading <a class="section-link" href="https://ian.wold.guru/Posts/sprache.html#further-reading">#</a></h2>
<p>I'll keep this list updated as I encounter more on the interwebs. This list should provide a good base to continue exploring the topics introduced in this tutorial.</p>
<ul>
<li>MSDN has <a href="https://msdn.microsoft.com/en-us/library/bb397926.aspx">extensive documentation</a> of LINQ.</li>
<li><a href="https://en.wikipedia.org/wiki/Parser_combinator">Wikipedia</a> provides an excellent starting point for learning more about parser-combinators</li>
<li>The <a href="https://github.com/sprache/Sprache">Sprache GitHub</a> links several examples, projects, and other tutorials.</li>
<li>The <a href="http://stackoverflow.com/unanswered/tagged/sprache">StackOverflow tag</a> receives regular traffic.</li>
</ul>
</section>
</section>

	</div>

	<div class="comments">
		<script src="https://giscus.app/client.js"
			data-repo="IanWold/ianwold.github.io"
			data-repo-id="MDEwOlJlcG9zaXRvcnkxNTk1NDkyNzI="
			data-category="Posts"
			data-category-id="DIC_kwDOCYKHWM4CZH2Y"
			data-mapping="title"
			data-strict="0"
			data-reactions-enabled="0"
			data-emit-metadata="0"
			data-input-position="top"
			data-theme="light"
			data-lang="en"
			data-loading="lazy"
			crossorigin="anonymous"
			async>
		</script>
	</div>
</div>

<div class="section-gray">
	<div class="content post-end">
		<img src="../images/hero1.svg" />
		<div class="bio">
			<h1>Hi, I'm Ian</h1>
			<p>
				I'm a software engineer, architect, and team leader in Minneapolis. My career has largely focused on .NET and web technologies, spread across several industries. Currently I'm working for Crate &amp; Barrel on their ecommerce solutions. You can find me on this blog, contributing to open source repositories, and at conferences around the Midwest.
			</p>
			<hr/>
			<p>
				If you'd like to keep up with me, please subscribe to my <a href="https://buttondown.email/ianwold" target="_blank">book club</a> or <a href="https://ian.wold.guru/feed.xml" target="_blank">RSS feed</a>. If you'd like to help me out with server costs, I would be forever grateful if you <a href="https://ko-fi.com/ianwold">bought me a coffee</a>!
			</p>
			<hr/>
			<p>
				Some other posts you might be interested in:
			</p>
			<div class="archive">
				<ul>
					
						<li>
							<a href="../Posts/sprache_comments.html">
								Parsing Comments in Sprache<small>I recently made a comment parser for the Sprache framework, and I wanted to give a basic run-down on how it works.</small>
							</a>
						</li>
					
						<li>
							<a href="../Posts/sprachedown.html">
								SpracheDown<small>I created a Markdown parser with the Sprache library after it was recommended to me at the Iowa Code Camp.</small>
							</a>
						</li>
					
						<li>
							<a href="../Posts/sprachejson.html">
								SpracheJSON<small>A small library serializing and deserializing JSON using Sprache.</small>
							</a>
						</li>
					
				</ul>
			</div>
		</div>
	</div>
</div>


		<footer>
			<div class="content content-footer">
				<span>
					Copyright &copy; Ian Wold. Built with <a href="https://www.github.com/IanWold/Metalsharp">Metalsharp</a>, <a href="https://torchlight.dev">Torchlight</a>, and <a href="https://ian.wold.guru/built_with.html">many more cool things</a>.
				</span>
				<div class="icon-links">
					<a href="https://github.com/ianwold" rel="me"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a>
					<a href="mailto:ian@wold.guru?subject=Hello" rel="me"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a>
					<a href="https://ko-fi.com/ianwold" target="_blank" rel="me"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-coffee"><path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line></svg></a>
					<a href="https://buttondown.email/ianwold" target="_blank" rel="me"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-book"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg></a>
					<a href="https://ian.wold.guru/feed.xml" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
				</div>
			</div>
		</footer>

		<script>
			
				window.addEventListener('DOMContentLoaded', () => {
					const observer = new IntersectionObserver(entries => {
						entries.forEach(entry => {
							const id = entry.target.getAttribute('id');
							let classList = document.querySelector(`.pane li a[href="#${id}"]`).parentElement.classList;

							if (entry.intersectionRatio > 0) {
								classList.add('active');
							} else {
								classList.remove('active');
							}
						});
					});

					document.querySelectorAll('section[id]').forEach((section) => {
						observer.observe(section);
					});
				});
			

			const darkModeToggle = document.getElementById("dark-mode-toggle");
			const body = document.body;


			function toggleDarkMode() {
				body.classList.toggle("dark");

				if (localStorage.getItem("dark") === "enabled") {
					localStorage.setItem("dark", "disabled");
				} else {
					localStorage.setItem("dark", "enabled");
				}
			}

			darkModeToggle.addEventListener("click", toggleDarkMode);

			if (localStorage.getItem("dark") === "enabled") {
				body.classList.toggle("dark");
			}
		</script>
	</body>
</html>
