

	


<html>
	<head>
		<link rel="stylesheet" href="../reset.css" />
		<link rel="stylesheet" href="../highlight/styles/monokai-sublime.min.css" />
		<link rel="stylesheet" href="../site.css" />
		
		<script src="https://unpkg.com/feather-icons"></script>

		<title>
			Ian Wold | Parsing Comments with Sprache 
		</title>
	</head>
	<body>
		<button id="dark-mode-toggle"><i data-feather="sun"></i></button>

		<nav class="content">
			<div class="headshot">
				<img src="../images/hero1.svg" />
			</div>
			<div class="title">
				<a href="../index.html">Ian Wold</a>
			</div>
			<ul>
				<li><a href="../about.html">About</a></li>
				<li><a href="../contact.html">Contact</a></li>
			</ul>
		</nav>
		
		




<header class="content">
	<h1>Parsing Comments with Sprache</h1>
	<small>
		<span class="date">
			<i data-feather="calendar"></i> 6 February 2015
		</span>
		<span class="time">
			<i data-feather="clock"></i> 1  Minute 
		</span>
	</small>
	<p>I recently made a comment parser for the Sprache framework, and I wanted to give a basic run-down on how it works.</p>
</header>

<div class="content hero">
	<img src="https://images.unsplash.com/photo-1617040619263-41c5a9ca7521?w=1000&h=525&fit=crop&crop=entropy" />
</div>

<div class="content">
	
	<div class="post">
		<p>I recently made a comment parser for the Sprache framework, and I wanted to give a basic run-down on how it works.</p>
<p>The CommentParser class gives you the option to define the header styles for comments, and it can parse both single- and multi-line comments. It's rather basic as of right now, but that's (hopefully) subject to change in the future.</p>
<p>Using CommentParser is pretty simple, but it's a tad different from the rest of the flow of Sprache as a combinator library. You'll need to make an instance of the CommentParser class, using the comment headers and (optional) newline character you require as arguments:</p>
<pre><code class="language-csharp">static CommentParser comments = new CommentParser(&quot;//&quot;, &quot;/*&quot;, &quot;*/&quot;);
</code></pre>
<p>From there, CommentParser gives you a couple parsers you can use to parse single- and multi-line comments:</p>
<pre><code class="language-csharp">static Parser&lt;string&gt; myParser = Parse.String(&quot;foobar&quot;).Text().Or(comments.AnyComment);
</code></pre>
<p>CommentParser.AnyComment will parse either single- or multi-line comments for you, while CommentParser.SingleLineComment and CommentParser.MultiLineComment will parse those individually.</p>
<p>A real, working example using the CommentParser class can be found in Sprache's <a href="https://github.com/sprache/Sprache/tree/master/src/XmlExample">XMLParser</a> example.</p>
<p>In the future, it would be awesome if multiple comment headers could be included, and if whitespace could be defined to include comments. Some work towards this effort has been done on my GitHub <a href="https://github.com/IanWold/Sprache/blob/Comments/src/Sprache/CommentParser.cs">here</a>.</p>

	</div>
	<div class="comments">
		<script src="https://giscus.app/client.js"
			data-repo="IanWold/ianwold.github.io"
			data-repo-id="MDEwOlJlcG9zaXRvcnkxNTk1NDkyNzI="
			data-category="Posts"
			data-category-id="DIC_kwDOCYKHWM4CZH2Y"
			data-mapping="title"
			data-strict="0"
			data-reactions-enabled="0"
			data-emit-metadata="0"
			data-input-position="top"
			data-theme="light"
			data-lang="en"
			data-loading="lazy"
			crossorigin="anonymous"
			async>
		</script>
	</div>
</div>

<div class="section-gray">
	<div class="content post-end">
		<img src="../images/hero1.svg" />
		<div class="bio">
			<h1>Hi, I'm Ian</h1>
			<p>
				I'm a software engineer, architect, and team leader in Minneapolis. My career has largely focused on .NET and web technologies, spread across several industries. Currently I'm working for Crate &amp; Barrel on their ecommerce solutions. You can find me on this blog, contributing to open source repositories, and at conferences around the Midwest.
			</p>
			<hr/>
			<p>
				Thank you for reading this post, I hope you found it valuable. If you'd like to keep up to date with my extremely consistent blog, please do subscribe to my <a href="#">RSS feed</a>.
			</p>
			<hr/>
			<p>
				Some other posts you might be interested in:
			</p>
			<div class="archive">
				<ul>
					
						<li>
							<a href="../Posts/sprache.html">
								An Introduction to Sprache<small>Sprache is a parser-combinator library for C# that uses Linq to construct parsers. In this post I describe the fundamentals of understanding grammars and parsing them with Sprache, with several real-world examples.</small>
							</a>
						</li>
					
						<li>
							<a href="../Posts/sprachedown.html">
								SpracheDown<small>I created a Markdown parser with the Sprache library after it was recommended to me at the Iowa Code Camp.</small>
							</a>
						</li>
					
						<li>
							<a href="../Posts/sprachejson.html">
								SpracheJSON<small>A small library serializing and deserializing JSON using Sprache.</small>
							</a>
						</li>
					
				</ul>
			</div>
		</div>
	</div>
</div>


		<footer>
			<div class="content content-footer">
				<span>
					Copyright &copy; Ian Wold. Site generated by <a href="https://www.github.com/IanWold/Metalsharp">Metalsharp</a> and hosted by <a href="https://www.github.com/IanWold/ianwold.github.io">GitHub Pages</a>.
				</span>
				<div class="icon-links">
					<a href="https://github.com/ianwold"><i data-feather="github"></i></a>
					<!--<a href="#"><i data-feather="rss"></i></a>-->
				</div>
			</div>
		</footer>

		<script src="../highlight/highlight.min.js"></script>
		<script>
			feather.replace();
			hljs.highlightAll();

			window.addEventListener('DOMContentLoaded', () => {
				const observer = new IntersectionObserver(entries => {
					entries.forEach(entry => {
						const id = entry.target.getAttribute('id');
						let classList = document.querySelector(`.pane li a[href="#${id}"]`).parentElement.classList;

						if (entry.intersectionRatio > 0) {
							classList.add('active');
						} else {
							classList.remove('active');
						}
					});
				});

				document.querySelectorAll('section[id]').forEach((section) => {
					observer.observe(section);
				});
			});

			const darkModeToggle = document.getElementById("dark-mode-toggle");
			const body = document.body;

			function toggleDarkMode() {
				body.classList.toggle("dark");

				if (localStorage.getItem("dark") === "enabled") {
					localStorage.setItem("dark", "disabled");
				} else {
					localStorage.setItem("dark", "enabled");
				}
			}

			darkModeToggle.addEventListener("click", toggleDarkMode);

			if (localStorage.getItem("dark") === "enabled") {
				body.classList.toggle("dark");
			}
		</script>
	</body>
</html>
